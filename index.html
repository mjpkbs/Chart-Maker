<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì°¨íŠ¸ ìƒì„±ê¸° - Chart Maker</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary-blue: #3B82F6;
            --secondary-blue: #1E40AF;
            --accent-orange: #F59E0B;
            --success-green: #10B981;
            --danger-red: #EF4444;
            --warning-yellow: #FBBF24;
            --info-cyan: #06B6D4;
            --purple: #8B5CF6;
            --pink: #EC4899;
            --indigo: #6366F1;
            --teal: #14B8A6;
            --gray-light: #F3F4F6;
            --gray-medium: #6B7280;
            --gray-dark: #546072;
            --gray-darker: #374151;
            --gray-darkest: #242634;
            --background-white: #FFFFFF;
            --background-dark: #1E3A8A;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans KR', 'AppleSDGothicNeo-Regular', 'Helvetica Neue', Helvetica, 'AppleSDGothicNeo-Regular', sans-serif;
            background: #546072;
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        .header .features {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
        }
        
        .panel {
            background: white;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .controls-panel {
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .panel h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #4a5568;
            border-bottom: 3px solid var(--primary-blue);
            padding-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .form-section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 12px;
            border-left: 4px solid var(--primary-blue);
        }
        
        .form-section h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--gray-darker);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #2d3748;
            font-size: 14px;
        }
        
        .form-group input, 
        .form-group select, 
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: white;
        }
        
        .form-group input:focus, 
        .form-group select:focus, 
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .chart-type-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .chart-type-btn {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .chart-type-btn.active {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
        }
        
        .chart-type-btn:hover:not(.active) {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
            transform: translateY(-1px);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            cursor: pointer;
            accent-color: var(--primary-blue);
        }
        
        .checkbox-group label {
            margin: 0;
            font-weight: 400;
            cursor: pointer;
            font-size: 14px;
        }
        
        .chart-options {
            display: none;
        }
        
        .chart-options.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .preview-canvas {
            width: 100%;
            height: 600px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: white;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .export-buttons {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 24px;
        }
        
        .export-buttons .btn {
            min-width: 200px;
        }
        
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .btn-small {
            padding: 8px 12px;
            font-size: 12px;
            min-width: 30px;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-primary {
            background: #3B82F6;
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        
        .btn-secondary {
            background: #F59E0B;
            color: white;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }
        
        .btn-success {
            background: #10B981;
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }
        
        .btn-danger {
            background: #EF4444;
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        .color-picker-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .color-picker-group input[type="color"] {
            width: 50px;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .color-item span {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
        }
        
        .slider-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .slider-group input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            appearance: none;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="number"] {
            width: 70px;
            padding: 8px;
            text-align: center;
        }
        
        .generate-btn {
            width: 100%;
            margin-top: 20px;
            font-size: 18px;
            padding: 16px;
        }
        
        .chart-url-section {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .chart-url-section h4 {
            color: var(--primary-blue);
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .chart-url {
            font-family: monospace;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            word-break: break-all;
            color: #475569;
            cursor: pointer;
        }
        
        .chart-url:hover {
            background: #f8fafc;
        }
        
        .series-container {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: #fafbfc;
        }
        
        .series-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .series-title {
            font-weight: 600;
            color: var(--gray-darker);
            font-size: 16px;
        }
        
        .highlight-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        
        .highlight-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .pie-container {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: #fafbfc;
        }
        
        .individual-bar-colors {
            background: #fefefe;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .individual-bar-colors h4 {
            margin-bottom: 12px;
            color: var(--gray-darker);
            font-size: 14px;
        }
        
        /* Scrollbar styling */
        .controls-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .controls-panel::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .controls-panel::-webkit-scrollbar-thumb {
            background: var(--primary-blue);
            border-radius: 3px;
        }
        
        .status-message {
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .status-success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }
        
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .export-buttons {
                flex-direction: column;
            }
        }
        /* ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ ìŠ¤íƒ€ì¼ */
.color-palette-section {
    margin: 15px 0;
    padding: 15px;
    background: #f8fafc;
    border-radius: 8px;
    border-left: 3px solid var(--primary-blue);
}

.color-palette-section h3 {
    font-size: 0.9rem;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--gray-darker);
}

.color-palette-grid {
    display: grid;
    grid-template-columns: repeat(30, 1fr);
    gap: 6px;
}

.palette-color {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    border: 1px solid rgba(0,0,0,0.1);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

@media (max-width: 768px) {
    .color-palette-grid {
        grid-template-columns: repeat(6, 1fr);
    }
    
    .palette-color {
        width: 20px;
        height: 20px;
    }
}

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š ì°¨íŠ¸ ìƒì„±ê¸°</h1>
            <p>KBS ë³´ë„ê·¸ë˜í”½ë¶€ ê·¸ë˜í”„ ìƒì„±ê¸°</p>
        </div>
        
        <div class="main-layout">
            <!-- ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
            <div class="panel controls-panel">
                <h2>âš™ï¸ ì°¨íŠ¸ ì„¤ì •</h2>
                         
                <div id="statusMessage"></div>
                
                <!-- ì°¨íŠ¸ íƒ€ì… ì„ íƒ -->
                <div class="form-section">
                    <h3>ğŸ“ˆ ì°¨íŠ¸ ìœ í˜•</h3>
                    <div class="chart-type-buttons">
                        <button class="chart-type-btn active" data-type="line">
                            ğŸ“ˆ ì„ í˜•
                        </button>
                        <button class="chart-type-btn" data-type="bar">
                            ğŸ“Š ë§‰ëŒ€
                        </button>
                        <button class="chart-type-btn" data-type="pie">
                            ğŸ¥§ íŒŒì´
                        </button>
                        <button class="chart-type-btn" data-type="table">
                            ğŸ“Š í‘œ
                        </button>
                    </div>
                </div>
                
                <!-- ì„ í˜• ì°¨íŠ¸ ì˜µì…˜ -->
                <div id="lineOptions" class="chart-options active">
                    <div class="form-section">
                        <h3>ğŸ“Š ì‹œë¦¬ì¦ˆ ì„¤ì •</h3>
                        <div class="form-group">
                            <label>ì„  ê°œìˆ˜</label>
                            <input type="number" id="numberOfLines" min="1" max="10" value="1">
                        </div>
                        <div class="checkbox-group" id="sameStyleCheckbox" style="display: none;">
                            <input type="checkbox" id="useSameStyle" checked>
                            <label for="useSameStyle">ê°™ì€ ìŠ¤íƒ€ì¼ ì ìš© (ìƒ‰ìƒ ì œì™¸)</label>
                        </div>
                    </div>
                    
                    <div id="lineSeriesContainer">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                    
                    <div class="form-section">
                        <h3>ğŸ“ˆ ì „ì—­ ì„¤ì •</h3>
                        <div class="form-group">
                            <label>Yì¶• ìµœì†Ÿê°’</label>
                            <input type="number" id="yAxisMin" placeholder="ê¸°ë³¸ê°’: ìë™">
                        </div>
                        <div class="form-group">
                            <label>ì°¨íŠ¸ í­: <span id="chartWidthValueLine">100</span>%</label>
                            <div class="slider-group">
                                <input type="range" id="chartWidthLine" min="50" max="150" value="100" oninput="updateSliderValue('chartWidthLine', 'chartWidthNumLine', 'chartWidthValueLine'); generateChart();">
                                <input type="number" id="chartWidthNumLine" min="50" max="150" value="100" oninput="updateSliderValue('chartWidthNumLine', 'chartWidthLine', 'chartWidthValueLine'); generateChart();">
                            </div>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="curvedLines">
                            <label for="curvedLines">ê³¡ì„  ê·¸ë˜í”„</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="fillUnderLine">
                            <label for="fillUnderLine">ì„  ì•„ë˜ ì±„ìš°ê¸°</label>
                        </div>
                    </div>
                </div>
                
                <!-- ë§‰ëŒ€ ì°¨íŠ¸ ì˜µì…˜ -->
                <div id="barOptions" class="chart-options">
                    <div class="form-section">
                        <h3>ğŸ“Š ì‹œë¦¬ì¦ˆ ì„¤ì •</h3>
                        <div class="form-group">
                            <label>ë§‰ëŒ€ ì„¸íŠ¸ ê°œìˆ˜</label>
                            <input type="number" id="numberOfBars" min="1" max="10" value="1">
                        </div>
                    </div>
                    
                    <div id="barSeriesContainer">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                    
                    <div class="form-section">
                        <h3>ğŸ“ˆ ì „ì—­ ì„¤ì •</h3>
                        <div class="form-group">
                            <label>Yì¶• ìµœì†Ÿê°’</label>
                            <input type="number" id="yAxisMinBar" placeholder="ê¸°ë³¸ê°’: ìë™">
                        </div>
                        <div class="form-group">
                            <label>ì°¨íŠ¸ í­: <span id="chartWidthValueBar">100</span>%</label>
                            <div class="slider-group">
                                <input type="range" id="chartWidthBar" min="50" max="150" value="100" oninput="updateSliderValue('chartWidthBar', 'chartWidthNumBar', 'chartWidthValueBar'); generateChart();">
                                <input type="number" id="chartWidthNumBar" min="50" max="150" value="100" oninput="updateSliderValue('chartWidthNumBar', 'chartWidthBar', 'chartWidthValueBar'); generateChart();">
                            </div>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="horizontalBars">
                            <label for="horizontalBars">ê°€ë¡œ ë§‰ëŒ€ ì°¨íŠ¸</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="stackedBars">
                            <label for="stackedBars">ëˆ„ì  ë§‰ëŒ€ ì°¨íŠ¸</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showBarValues" checked>
                            <label for="showBarValues">ë°ì´í„° ê°’ í‘œì‹œ</label>
                        </div>
                        <div class="form-group">
                            <label>ë§‰ëŒ€ ë„ˆë¹„: <span id="barWidthValue">110</span>px</label>
                            <div class="slider-group">
                                <input type="range" id="barWidth" min="20" max="200" value="110">
                                <input type="number" id="barWidthNum" min="20" max="200" value="110">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>ë§‰ëŒ€ ê°„ê²©: <span id="barSpacingValue">5</span>px</label>
                            <div class="slider-group">
                                <input type="range" id="barSpacing" min="0" max="50" value="5" oninput="updateSliderValue('barSpacing', 'barSpacingNum', 'barSpacingValue'); generateChart();">
                                <input type="number" id="barSpacingNum" min="0" max="50" value="5" oninput="updateSliderValue('barSpacingNum', 'barSpacing', 'barSpacingValue'); generateChart();">
                            </div>
                        </div>
                        <!-- Arrow Bars controls (added) -->
                        <div class="checkbox-group">
                            <input type="checkbox" id="arrowBars">
                            <label for="arrowBars">í™”ì‚´í‘œ</label>
                        </div>
                        <div id="arrowControls" style="display:none;">
                            <div class="form-group">
                                <label>í™”ì‚´í‘œ ë¨¸ë¦¬ ë„ˆë¹„: <span id="arrowHeadWidthValue">145</span>px</label>
                                <div class="slider-group">
                                    <input type="range" id="arrowHeadWidth" min="10" max="300" value="145" oninput="updateSliderValue('arrowHeadWidth','arrowHeadWidthNum','arrowHeadWidthValue'); generateChart();">
                                    <input type="number" id="arrowHeadWidthNum" min="10" max="300" value="145" oninput="updateSliderValue('arrowHeadWidthNum','arrowHeadWidth','arrowHeadWidthValue'); generateChart();">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>í™”ì‚´í‘œ ë¨¸ë¦¬ ë†’ì´: <span id="arrowHeadHeightValue">30</span>px</label>
                                <div class="slider-group">
                                    <input type="range" id="arrowHeadHeight" min="5" max="300" value="30" oninput="updateSliderValue('arrowHeadHeight','arrowHeadHeightNum','arrowHeadHeightValue'); generateChart();">
                                    <input type="number" id="arrowHeadHeightNum" min="5" max="300" value="30" oninput="updateSliderValue('arrowHeadHeightNum','arrowHeadHeight','arrowHeadHeightValue'); generateChart();">
                                </div>
                            </div>
                        </div>
    
                        
                        <div class="form-group">
                            <label>ìˆ˜ì¹˜ í…ìŠ¤íŠ¸ í¬ê¸°: <span id="barValueFontSizeValue">55</span>px</label>
                            <div class="slider-group">
                                <input type="range" id="barValueFontSize" min="12" max="100" value="55" oninput="updateSliderValue('barValueFontSize', 'barValueFontSizeNum', 'barValueFontSizeValue'); generateChart();">
                                <input type="number" id="barValueFontSizeNum" min="12" max="100" value="55" oninput="updateSliderValue('barValueFontSizeNum', 'barValueFontSize', 'barValueFontSizeValue'); generateChart();">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- íŒŒì´ ì°¨íŠ¸ ì˜µì…˜ -->
                <div id="pieOptions" class="chart-options">
                    <div class="form-section">
                        <h3>ğŸ“Š ì‹œë¦¬ì¦ˆ ì„¤ì •</h3>
                        <div class="form-group">
                            <label>íŒŒì´ ì°¨íŠ¸ ê°œìˆ˜</label>
                            <select id="numberOfPies">
                                <option value="1">1ê°œ</option>
                                <option value="2">2ê°œ</option>
                            </select>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showPieLabels">
                            <label for="showPieLabels">ë ˆì´ë¸” í‘œì‹œ</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showPieValues" checked>
                            <label for="showPieValues">ë°ì´í„° ê°’ í‘œì‹œ</label>
                        </div>
                        
                        <div class="form-group">
                            <label>ìˆ˜ì¹˜ í…ìŠ¤íŠ¸ í¬ê¸°: <span id="pieValueFontSizeValue">60</span>px</label>
                            <div class="slider-group">
                                <input type="range" id="pieValueFontSize" min="12" max="100" value="60" oninput="updateSliderValue('pieValueFontSize', 'pieValueFontSizeNum', 'pieValueFontSizeValue'); generateChart();">
                                <input type="number" id="pieValueFontSizeNum" min="12" max="100" value="60" oninput="updateSliderValue('pieValueFontSizeNum', 'pieValueFontSize', 'pieValueFontSizeValue'); generateChart();">
                            </div>
                        </div>
                    </div>
                    
                    <div id="pieSeriesContainer">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                </div>
                <!-- í…Œì´ë¸” ì°¨íŠ¸ ì˜µì…˜ -->
<div id="tableOptions" class="chart-options">
    <div class="form-section">
        <h3>ğŸ“‹ í…Œì´ë¸” ì„¸íŒ…</h3>
        <div class="form-group">
            <label>í–‰/ì—´ ì¡°ì ˆ</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <button type="button" class="btn btn-primary btn-small" onclick="adjustTableSize('rows', -1)">-í–‰</button>
                <span>í–‰: <span id="tableRowsCount">3</span></span>
                <button type="button" class="btn btn-primary btn-small" onclick="adjustTableSize('rows', 1)">+í–‰</button>
                <button type="button" class="btn btn-primary btn-small" onclick="adjustTableSize('cols', -1)">-ì—´</button>
                <span>ì—´: <span id="tableColsCount">3</span></span>
                <button type="button" class="btn btn-primary btn-small" onclick="adjustTableSize('cols', 1)">+ì—´</button>
            </div>
        </div>
        
        <div class="form-group">
            <label>ê°€ë¡œí­: <span id="tableWidthValue">100</span>%</label>
            <div class="slider-group">
                <input type="range" id="tableWidth" min="50" max="150" value="100" oninput="updateSliderValue('tableWidth', 'tableWidthNum', 'tableWidthValue'); generateChart();">
                <input type="number" id="tableWidthNum" min="50" max="150" value="100" oninput="updateSliderValue('tableWidthNum', 'tableWidth', 'tableWidthValue'); generateChart();">
            </div>
        </div>
        
        <div class="form-group">
            <label>ì„¸ë¡œí­: <span id="tableHeightValue">100</span>%</label>
            <div class="slider-group">
                <input type="range" id="tableHeight" min="50" max="150" value="100" oninput="updateSliderValue('tableHeight', 'tableHeightNum', 'tableHeightValue'); generateChart();">
                <input type="number" id="tableHeightNum" min="50" max="150" value="100" oninput="updateSliderValue('tableHeightNum', 'tableHeight', 'tableHeightValue'); generateChart();">
            </div>
        </div>
    </div>
    
    <!-- ê¸°ì¡´ í—¤ë” ì„¹ì…˜ì— ì¶”ê°€ -->
<div class="form-section">
    <h3>ğŸ“ í—¤ë”</h3>
    <div class="form-group">
        <label>ë°°ê²½ìƒ‰</label>
        <input type="color" id="headerBgColor" value="#b4bdc6" oninput="generateChart()">
    </div>
    <div class="form-group">
        <label>ê¸€ììƒ‰</label>
        <input type="color" id="headerTextColor" value="#FFFFFF" oninput="generateChart()">
    </div>
    <!-- ìƒˆë¡œ ì¶”ê°€í•  ë¶€ë¶„ -->
    <div class="form-group">
        <label>í…ìŠ¤íŠ¸ í¬ê¸°: <span id="headerFontSizeValue">30</span>px</label>
        <div class="slider-group">
            <input type="range" id="headerFontSize" min="12" max="60" value="30" oninput="updateSliderValue('headerFontSize', 'headerFontSizeNum', 'headerFontSizeValue'); generateChart();">
            <input type="number" id="headerFontSizeNum" min="12" max="60" value="30" oninput="updateSliderValue('headerFontSizeNum', 'headerFontSize', 'headerFontSizeValue'); generateChart();">
        </div>
    </div>
</div>
    
    <div class="form-section">
        <h3>ğŸ—ï¸ í–‰ì—´</h3>
        <div class="checkbox-group">
            <input type="checkbox" id="showRowNumbers" checked oninput="generateChart()">
            <label for="showRowNumbers">í–‰ ìˆ«ì</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="stripedRows" checked oninput="toggleStripedRows(); generateChart()">
            <label for="stripedRows">Striped Rows</label>
        </div>
        
        <div id="stripedRowsSettings">
            <div class="form-group">
                <label>í™€ìˆ˜ ë°°ê²½ìƒ‰</label>
                <input type="color" id="oddRowBgColor" value="#F9FAFB" oninput="generateChart()">
            </div>
            <div class="form-group">
                <label>í™€ìˆ˜ ê¸€ììƒ‰</label>
                <input type="color" id="oddRowTextColor" value="#374151" oninput="generateChart()">
            </div>
            <div class="form-group">
                <label>ì§ìˆ˜ ë°°ê²½ìƒ‰</label>
                <input type="color" id="evenRowBgColor" value="#FFFFFF" oninput="generateChart()">
            </div>
            <div class="form-group">
                <label>ì§ìˆ˜ ê¸€ììƒ‰</label>
                <input type="color" id="evenRowTextColor" value="#374151" oninput="generateChart()">
            </div>
        </div>
        
        <div id="uniformRowsSettings" style="display: none;">
            <div class="form-group">
                <label>ë°°ê²½ìƒ‰</label>
                <input type="color" id="uniformRowBgColor" value="#FFFFFF" oninput="generateChart()">
            </div>
            <div class="form-group">
                <label>ê¸€ììƒ‰</label>
                <input type="color" id="uniformRowTextColor" value="#374151" oninput="generateChart()">
            </div>
        </div>
    </div>
    
    <div class="form-section">
        <h3>ğŸ–¼ï¸ í…Œë‘ë¦¬ì„ </h3>
        <div class="form-group">
            <label>ìƒ‰ìƒ</label>
            <input type="color" id="borderColor" value="#E5E7EB" oninput="generateChart()">
        </div>
        <div class="form-group">
            <label>ìŠ¤íƒ€ì¼</label>
            <select id="borderStyle" oninput="generateChart()">
                <option value="solid">ì‹¤ì„ </option>
                <option value="dashed">ì ì„ </option>
                <option value="dotted">ì›ì ì„ </option>
                <option value="double">ì´ì¤‘ì„ </option>
            </select>
        </div>
        <div class="form-group">
            <label>í…Œë‘ë¦¬ êµµê¸°: <span id="borderWidthValue">3</span>px</label>
            <div class="slider-group">
                <input type="range" id="borderWidth" min="1" max="10" value="3" oninput="updateSliderValue('borderWidth', 'borderWidthNum', 'borderWidthValue'); generateChart();">
                <input type="number" id="borderWidthNum" min="1" max="10" value="3" oninput="updateSliderValue('borderWidthNum', 'borderWidth', 'borderWidthValue'); generateChart();">
            </div>
        </div>
    </div>
    
    <div class="form-section">
    <h3>âœï¸ í…ìŠ¤íŠ¸</h3>
    <div class="form-group">
        <label>ìƒ‰ìƒ</label>
        <input type="color" id="textColor" value="#374151" oninput="generateChart()">
    </div>
    <div class="form-group">
        <label>í…ìŠ¤íŠ¸ ì •ë ¬</label>
        <select id="textAlign" oninput="generateChart()">
    <option value="left">ì™¼ìª½</option>
    <option value="center" selected>ì¤‘ê°„</option>
    <option value="right">ì˜¤ë¥¸ìª½</option>
</select>
    </div>
    <!-- ìƒˆë¡œ ì¶”ê°€í•  ë¶€ë¶„ -->
    <div class="form-group">
        <label>í…ìŠ¤íŠ¸ í¬ê¸°: <span id="bodyFontSizeValue">30</span>px</label>
        <div class="slider-group">
            <input type="range" id="bodyFontSize" min="12" max="60" value="30" oninput="updateSliderValue('bodyFontSize', 'bodyFontSizeNum', 'bodyFontSizeValue'); generateChart();">
            <input type="number" id="bodyFontSizeNum" min="12" max="60" value="30" oninput="updateSliderValue('bodyFontSizeNum', 'bodyFontSize', 'bodyFontSizeValue'); generateChart();">
        </div>
    </div>
    <div class="form-group">
        <label>íŒ¨ë”©: <span id="cellPaddingValue">8</span>px</label>
        <div class="slider-group">
            <input type="range" id="cellPadding" min="2" max="20" value="8" oninput="updateSliderValue('cellPadding', 'cellPaddingNum', 'cellPaddingValue'); generateChart();">
            <input type="number" id="cellPaddingNum" min="2" max="20" value="8" oninput="updateSliderValue('cellPaddingNum', 'cellPadding', 'cellPaddingValue'); generateChart();">
        </div>
    </div>
</div>
    
    <div class="form-section">
        <h3>ğŸ“Š í…Œì´ë¸” ë°ì´í„°</h3>
        <div id="tableDataContainer">
            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
        </div>
    </div>
</div>
                
                <!-- ê²©ìì„  ì„¤ì • -->
                <div class="form-section">
                    <h3>ğŸ”² ê²©ìì„  ì„¤ì •</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGridlines" checked>
                        <label for="showGridlines">ê²©ìì„  í‘œì‹œ</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAxisLabels" checked>
                        <label for="showAxisLabels">ëˆˆê¸ˆì„  ìˆ«ì í‘œì‹œ</label>
                    </div>
                    <div class="form-group">
                        <label>ëˆˆê¸ˆ ê°„ê²©</label>
                        <input type="number" id="gridlineInterval" placeholder="ì˜ˆ: 7 (0, 7, 14, 21...)" value="10" min="1">
                    </div>
                </div>
                
                <!-- ê°•ì¡° ì„¤ì • - ëª¨ë“  ì°¨íŠ¸ íƒ€ì…ì— ì ìš© -->
                <div class="form-section">
                    <h3>â­ ê°•ì¡° ì„¤ì •</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableHighlight">
                        <label for="enableHighlight">ìš”ì†Œ ê°•ì¡°</label>
                    </div>
                    <div id="highlightContainer" style="display: none;">
                        <div class="highlight-controls">
                            <button type="button" class="btn btn-primary btn-small" onclick="addHighlight()">+ ê°•ì¡° ì¶”ê°€</button>
                        </div>
                        <div id="highlightList">
                            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                        </div>
                    </div>
                </div>

                <!-- ë°°ê²½ ì„¤ì • -->
                <div class="form-section">
                    <h3>ğŸ¨ ë°°ê²½ ì„¤ì •</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showBackground" checked>
                        <label for="showBackground">ë°°ê²½ í‘œì‹œ</label>
                    </div>
                    <div id="backgroundTypeContainer">
                        <div class="form-group">
                            <label>ë°°ê²½ ì¢…ë¥˜</label>
                            <select id="backgroundType">
                                <option value="light">ë°ì€ ë°°ê²½</option>
                                <option value="dark">ì–´ë‘ìš´ ë°°ê²½</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- ì¦ê²¨ì°¾ê¸° (Favorites) Section -->
                <div class="form-section">
                    <h3>â­ ì¦ê²¨ì°¾ê¸° (Favorites)</h3>
                    <div class="form-group">
                        <label>ì¦ê²¨ì°¾ê¸° ì´ë¦„</label>
                        <input type="text" id="favoriteName" placeholder="ì˜ˆ: My Blue Theme">
                    </div>
                    <div class="form-group">
                        <label>ì €ì¥ëœ ì¦ê²¨ì°¾ê¸°</label>
                        <select id="favoritesDropdown"></select>
                    </div>
                    <div class="form-group" style="display:flex; gap:10px;">
                        <button type="button" class="btn btn-primary btn-small" onclick="saveFavorite()">ì €ì¥</button>
                        <button type="button" class="btn btn-success btn-small" onclick="loadFavorite()">ë¶ˆëŸ¬ì˜¤ê¸°</button>
                        <button type="button" class="btn btn-danger btn-small" onclick="deleteFavorite()">ì‚­ì œ</button>
                    </div>
                </div>
                
                
                <button class="btn btn-success generate-btn" onclick="generateChart()">
                    ğŸ¨ ì°¨íŠ¸ ìƒì„±í•˜ê¸°
                </button>
            </div>
            
            <!-- ë¯¸ë¦¬ë³´ê¸° íŒ¨ë„ -->
            <div class="panel">
                <h2>ğŸ‘ï¸ ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°</h2>
                <canvas id="previewCanvas" class="preview-canvas"></canvas>
                
                <!-- ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ ì„¹ì…˜ -->
<div class="color-palette-section">
    <h3>Color Palette</h3>
    <div class="color-palette-grid">
        
        <div class="palette-color" style="background-color: #7faef5"></div>
        <div class="palette-color" style="background-color: #5a8edb"></div>
        <div class="palette-color" style="background-color: #2f62af"></div>
        <div class="palette-color" style="background-color: #1f4e95"></div>
        <div class="palette-color" style="background-color: #0f3564"></div>
        <div class="palette-color" style="background-color: #172c4d"></div>
        <div class="palette-color" style="background-color: #d6dade"></div>
        <div class="palette-color" style="background-color: #b4bdc6"></div>
        <div class="palette-color" style="background-color: #8896a1"></div>
        <div class="palette-color" style="background-color: #546072"></div>
        <div class="palette-color" style="background-color: #3c434f"></div>
        <div class="palette-color" style="background-color: #242634"></div>
        <div class="palette-color" style="background-color: #20ae98"></div>
        <div class="palette-color" style="background-color: #22cc92"></div>
        <div class="palette-color" style="background-color: #dd6f2d"></div>
        <div class="palette-color" style="background-color: #f17d38"></div>
        <div class="palette-color" style="background-color: #859cc1"></div>
    </div>
</div>

                <div class="export-buttons">
                    <button class="btn btn-secondary" onclick="exportPSD()">
                        ğŸ¨ PSD íŒŒì¼ë¡œ ì €ì¥
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let currentChart = null;
        let chartConfig = {
            type: 'line',
            backgroundColor: 'white',
            data: {},
            options: {}
        };
        
        let highlightCounter = 0;
let typeSettings = { line: null, bar: null, pie: null };

// í…Œì´ë¸” ê´€ë ¨ ì „ì—­ ë³€ìˆ˜
let tableRows = 3;
let tableCols = 3;
let tableData = [];

// í…Œì´ë¸” ë°ì´í„° ì´ˆê¸°í™”
function initializeTableData() {
    tableData = [];
    for (let i = 0; i < tableRows; i++) {
        const row = [];
        for (let j = 0; j < tableCols; j++) {
            if (i === 0) {
                row.push(`í—¤ë” ${j + 1}`);
            } else {
                row.push(`ë°ì´í„° ${i}-${j + 1}`);
            }
        }
        tableData.push(row);
    }
    updateTableDataInputs();
}

// í…Œì´ë¸” í¬ê¸° ì¡°ì ˆ
function adjustTableSize(type, delta) {
    if (type === 'rows') {
        const newRows = Math.max(2, Math.min(10, tableRows + delta));
        if (newRows !== tableRows) {
            if (delta > 0) {
                // í–‰ ì¶”ê°€
                const newRow = [];
                for (let j = 0; j < tableCols; j++) {
                    newRow.push(`ë°ì´í„° ${newRows}-${j + 1}`);
                }
                tableData.push(newRow);
            } else {
                // í–‰ ì œê±°
                tableData.pop();
            }
            tableRows = newRows;
            document.getElementById('tableRowsCount').textContent = tableRows;
        }
    } else if (type === 'cols') {
        const newCols = Math.max(2, Math.min(10, tableCols + delta));
        if (newCols !== tableCols) {
            if (delta > 0) {
                // ì—´ ì¶”ê°€
                for (let i = 0; i < tableRows; i++) {
                    if (i === 0) {
                        tableData[i].push(`í—¤ë” ${newCols}`);
                    } else {
                        tableData[i].push(`ë°ì´í„° ${i + 1}-${newCols}`);
                    }
                }
            } else {
                // ì—´ ì œê±°
                for (let i = 0; i < tableRows; i++) {
                    tableData[i].pop();
                }
            }
            tableCols = newCols;
            document.getElementById('tableColsCount').textContent = tableCols;
        }
    }
    updateTableDataInputs();
    generateChart();
}

// Striped Rows í† ê¸€
function toggleStripedRows() {
    const stripedRows = document.getElementById('stripedRows').checked;
    const stripedSettings = document.getElementById('stripedRowsSettings');
    const uniformSettings = document.getElementById('uniformRowsSettings');
    
    stripedSettings.style.display = stripedRows ? 'block' : 'none';
    uniformSettings.style.display = stripedRows ? 'none' : 'block';
}

// í…Œì´ë¸” ë°ì´í„° ì…ë ¥ í•„ë“œ ì—…ë°ì´íŠ¸
function updateTableDataInputs() {
    const container = document.getElementById('tableDataContainer');
    container.innerHTML = '';
    
    for (let i = 0; i < tableRows; i++) {
        for (let j = 0; j < tableCols; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'form-group';
            inputGroup.innerHTML = `
                <label>${i === 0 ? 'í—¤ë”' : 'í–‰ ' + i} - ì—´ ${j + 1}</label>
                <input type="text" id="tableCell_${i}_${j}" value="${tableData[i][j]}" oninput="updateTableData(${i}, ${j}, this.value); generateChart();">
            `;
            container.appendChild(inputGroup);
        }
    }
}

// í…Œì´ë¸” ë°ì´í„° ì—…ë°ì´íŠ¸
function updateTableData(row, col, value) {
    if (tableData[row]) {
        tableData[row][col] = value;
    }
}

/* Capture current DOM inputs/selects into a snapshot */
function captureTypeSettings(type) {
    if (!type) return;
    const snapshot = {
        numberOfLines: document.getElementById('numberOfLines')?.value || null,
        numberOfBars: document.getElementById('numberOfBars')?.value || null,
        numberOfPies: document.getElementById('numberOfPies')?.value || null,
        inputs: Array.from(document.querySelectorAll('input, select, textarea')).map(el => ({
            id: el.id,
            type: el.type,
            value: el.type === 'checkbox' ? el.checked : el.value
        }))
    };
    typeSettings[type] = snapshot;
}

/* Apply a previously captured snapshot to DOM */
function applyTypeSettings(type) {
    const snapshot = typeSettings[type];
    if (!snapshot) return;

    // Restore counts first so the right controls exist
    if (snapshot.numberOfLines && document.getElementById('numberOfLines')) {
        document.getElementById('numberOfLines').value = snapshot.numberOfLines;
    }
    if (snapshot.numberOfBars && document.getElementById('numberOfBars')) {
        document.getElementById('numberOfBars').value = snapshot.numberOfBars;
    }
    if (snapshot.numberOfPies && document.getElementById('numberOfPies')) {
        document.getElementById('numberOfPies').value = snapshot.numberOfPies;
    }
    updateSeriesContainers();

    // Restore inputs
    snapshot.inputs.forEach(s => {
        const el = document.getElementById(s.id);
        if (!el) return;
        if (s.type === 'checkbox') {
            el.checked = s.value;
        } else {
            el.value = s.value;
        }
    });
    // Rerender
    generateChart();
}

        
        // Hex to RGBA ë³€í™˜ í•¨ìˆ˜
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateSliderValue(sourceId, targetId, labelId) {
            const source = document.getElementById(sourceId);
            const target = document.getElementById(targetId);
            const label = document.getElementById(labelId);
            
            if (source && target) {
                target.value = source.value;
            }
            if (label && source) {
                label.textContent = source.value;
            }
        }
        
        // ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (ìƒˆë¡œìš´ ë¸”ë£¨ ê·¸ë¼ë””ì–¸íŠ¸ ìƒ‰ìƒ)
        const colorPalette = [
            '#1E3A8A', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899',
            '#6366F1', '#14B8A6', '#F97316', '#84CC16', '#06B6D4', '#A855F7'
        ];
        
        // íŒŒì´ ì°¨íŠ¸ ì „ìš© ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const pieColorPalette = [
            '#7faef5', '#5a8edb', '#2f62af', '#1f4e95', '#0f3564', '#172c4d',
            '#7faef5', '#5a8edb', '#2f62af', '#1f4e95', '#0f3564', '#172c4d'
        ];
        
        // ì•± ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ“Š ì°¨íŠ¸ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹œì‘');
            showStatus('ì•±ì„ ì´ˆê¸°í™”í•˜ëŠ” ì¤‘...', 'success');
            
            try {
                initializeEventListeners();
                updateSeriesContainers();
                updateHighlightLabel();
                generateChart();
                // ê¸°ì¡´ ì´ˆê¸°í™” ì½”ë“œ ë’¤ì— ì¶”ê°€
                initializeTableData();
                showStatus('âœ… ì¤€ë¹„ ì™„ë£Œ! ì°¨íŠ¸ë¥¼ ìˆ˜ì •í•´ë³´ì„¸ìš”', 'success');
            } catch (error) {
                console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                showStatus('âš  ì´ˆê¸°í™” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
            }
        });
        
        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(message, type = 'success') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 3000);
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì´ˆê¸°í™”
        function initializeEventListeners() {
            console.log('ğŸ”§ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì¤‘...');
            
            // ì°¨íŠ¸ íƒ€ì… ë²„íŠ¼
            document.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                                        // Capture current type settings before switching
                    try { captureTypeSettings(chartConfig.type); } catch(e) { console.warn('captureTypeSettings failed', e); }
document.querySelectorAll('.chart-type-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    const chartType = this.dataset.type;
                    chartConfig.type = chartType;
                    showChartOptions(chartType);
                    updateHighlightLabel();
                    updateSeriesContainers();
                    // Apply saved settings for the new type (if any)
                    try { applyTypeSettings(chartType); } catch(e) { console.warn('applyTypeSettings failed', e); }
                    
                    generateChart();
                    showStatus(`ğŸ“ˆ ${this.textContent.trim()} ì°¨íŠ¸ë¡œ ë³€ê²½ë¨`, 'success');
                });
            });
            
            // ë°°ê²½ í‘œì‹œ/ìˆ¨ê¸°ê¸°
            document.getElementById('showBackground').addEventListener('change', function() {
                const backgroundTypeDiv = document.getElementById('backgroundTypeContainer');
                backgroundTypeDiv.style.display = this.checked ? 'block' : 'none';
                generateChart();
                showStatus(`ë°°ê²½ ${this.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`, 'success');
            });
            
            // ë°°ê²½ íƒ€ì… ë³€ê²½
            document.getElementById('backgroundType').addEventListener('change', function() {
                chartConfig.backgroundColor = this.value === 'dark' ? 'dark' : 'white';
    
                // ì–´ë‘ìš´ ë°°ê²½ì¼ ë•Œ ëª¨ë“  ìƒ‰ìƒ ì…ë ¥ê°’ì„ #7faef5ë¡œ ë³€ê²½
                if (this.value === 'dark') {
                    updateColorsForDarkBackground();
                } else {
                    resetColorsForLightBackground();
                }
    
                generateChart();
                showStatus(`ë°°ê²½ì„ ${this.value === 'dark' ? 'ì–´ë‘ìš´' : 'ë°ì€'} í…Œë§ˆë¡œ ë³€ê²½`, 'success');
            });

            // ì–´ë‘ìš´ ë°°ê²½ìš© ìƒ‰ìƒ ë³€ê²½ í•¨ìˆ˜
            function updateColorsForDarkBackground() {
                // ì„  ê·¸ë˜í”„ ìƒ‰ìƒ ë³€ê²½
                const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
                for (let i = 0; i < numberOfLines; i++) {
                    const lineColorInput = document.getElementById(`lineColor${i}`);
                    const pointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
                     if (lineColorInput) lineColorInput.value = '#7faef5';
                        if (pointStrokeColorInput) pointStrokeColorInput.value = '#7faef5';
                }
    
                // ë°” ê·¸ë˜í”„ ìƒ‰ìƒ ë³€ê²½
                const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
                for (let i = 0; i < numberOfBars; i++) {
                    const barColorInput = document.getElementById(`barColor${i}`);
                    if (barColorInput) barColorInput.value = '#7faef5';
                }
            }

            // ë°ì€ ë°°ê²½ìš© ìƒ‰ìƒ ë³µì› í•¨ìˆ˜
            function resetColorsForLightBackground() {
                const originalColors = [
                    '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899',
                    '#6366F1', '#14B8A6', '#F97316', '#84CC16', '#06B6D4', '#A855F7'
                ];
    
                // ì„  ê·¸ë˜í”„ ìƒ‰ìƒ ë³µì›
                const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
                for (let i = 0; i < numberOfLines; i++) {
                    const lineColorInput = document.getElementById(`lineColor${i}`);
                    const pointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
                    if (lineColorInput) lineColorInput.value = originalColors[i % originalColors.length];
                    if (pointStrokeColorInput) pointStrokeColorInput.value = originalColors[i % originalColors.length];
                }
    
                // ë°” ê·¸ë˜í”„ ìƒ‰ìƒ ë³µì›
                const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
                for (let i = 0; i < numberOfBars; i++) {
                    const barColorInput = document.getElementById(`barColor${i}`);
                    if (barColorInput) barColorInput.value = originalColors[i % originalColors.length];
                }
            }
            
            // ê²©ìì„  í‘œì‹œ/ìˆ¨ê¸°ê¸°
            document.getElementById('showGridlines').addEventListener('change', function() {
                generateChart();
                showStatus(`ê²©ìì„  ${this.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`, 'success');
            });
            
            // ëˆˆê¸ˆì„  ìˆ«ì í‘œì‹œ/ìˆ¨ê¸°ê¸°
            document.getElementById('showAxisLabels').addEventListener('change', function() {
                generateChart();
                showStatus(`ëˆˆê¸ˆì„  ìˆ«ì ${this.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`, 'success');
            });
            
            // ì‚¬ìš©ì ì§€ì • ê²©ìì„  

            
            // ê²©ìì„  ê°„ê²© ì…ë ¥
            document.getElementById('gridlineInterval').addEventListener('input', debounce(() => {
                generateChart();
            }, 300));
            
            // ê°•ì¡° ê¸°ëŠ¥ í† ê¸€
            document.getElementById('enableHighlight').addEventListener('change', function() {
                const highlightDiv = document.getElementById('highlightContainer');
                highlightDiv.style.display = this.checked ? 'block' : 'none';
                if (this.checked && document.getElementById('highlightList').children.length === 0) {
                    addHighlight();
                }
                generateChart();
            });
            
            // íŒŒì´ ì°¨íŠ¸ ë ˆì´ë¸” í‘œì‹œ/ìˆ¨ê¸°ê¸°
            document.getElementById('showPieLabels').addEventListener('change', function() {
                generateChart();
                showStatus(`íŒŒì´ ì°¨íŠ¸ ë ˆì´ë¸” ${this.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`, 'success');
            });
            
            // íŒŒì´ ì°¨íŠ¸ ê°’ í‘œì‹œ/ìˆ¨ê¸°ê¸°
            document.getElementById('showPieValues').addEventListener('change', function() {
                generateChart();
                showStatus(`íŒŒì´ ì°¨íŠ¸ ê°’ ${this.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`, 'success');
            });
            
            // ë§‰ëŒ€ ì°¨íŠ¸ ê°’ í‘œì‹œ/ìˆ¨ê¸°ê¸°
            document.getElementById('showBarValues').addEventListener('change', function() {
                generateChart();
                showStatus(`ë§‰ëŒ€ ì°¨íŠ¸ ê°’ ${this.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`, 'success');
            });
            
            // ê°•ì¡° í•­ëª©ë“¤ ìƒˆë¡œê³ ì¹¨ (ì°¨íŠ¸ íƒ€ì… ë³€ê²½ì‹œ)
            function refreshHighlights() {
                const highlightList = document.getElementById('highlightList');
                if (!highlightList) return;
                
                // ê¸°ì¡´ í•­ëª©ë“¤ì˜ ê°’ì„ ì €ì¥
                const existingHighlights = [];
                const highlightItems = document.querySelectorAll('#highlightList .highlight-item');
                
                highlightItems.forEach(item => {
                    const selects = item.querySelectorAll('select');
                    const indexInput = item.querySelector('input[type="number"]');
                    
                    if (indexInput && indexInput.value) {
                        const highlight = {
                            index: indexInput.value
                        };
                        
                        // ì‹œë¦¬ì¦ˆì™€ ìƒ‰ìƒ ê°’ ì €ì¥
                        if (selects.length >= 2) {
                            highlight.series = selects[0].value;
                            highlight.color = selects[1].value;
                        } else if (selects.length === 1) {
                            highlight.series = '1';
                            highlight.color = selects[0].value;
                        }
                        
                        existingHighlights.push(highlight);
                    }
                });
                
                // ëª¨ë“  í•­ëª© ì œê±°
                highlightList.innerHTML = '';
                highlightCounter = 0;
                
                // ì €ì¥ëœ ê°’ë“¤ë¡œ ìƒˆë¡œìš´ í•­ëª©ë“¤ ìƒì„±
                existingHighlights.forEach(highlight => {
                    addHighlight();
                    const newItem = highlightList.lastElementChild;
                    if (newItem) {
                        const selects = newItem.querySelectorAll('select');
                        const indexInput = newItem.querySelector('input[type="number"]');
                        
                        if (indexInput) {
                            indexInput.value = highlight.index;
                        }
                        
                        if (selects.length >= 2 && highlight.series) {
                            selects[0].value = highlight.series;
                            if (highlight.color) selects[1].value = highlight.color;
                        } else if (selects.length === 1 && highlight.color) {
                            selects[0].value = highlight.color;
                        }
                    }
                });
            }
            
            // ì‹œë¦¬ì¦ˆ ê°œìˆ˜ ë³€ê²½
            document.getElementById('numberOfLines').addEventListener('change', function() {
                updateSeriesContainers();
                refreshHighlights();
                generateChart();
            });
            
            document.getElementById('numberOfBars').addEventListener('change', function() {
                updateSeriesContainers();
                refreshHighlights();
                generateChart();
            });
            
            document.getElementById('numberOfPies').addEventListener('change', function() {
                updateSeriesContainers();
                refreshHighlights();
                generateChart();
            });
            
            // ìŠ¬ë¼ì´ë” ë™ê¸°í™” ë° ë¼ë²¨ ì—…ë°ì´íŠ¸
            setupSlider('barWidth', 'barWidthNum', 'barWidthValue');
            
            // ì‹¤ì‹œê°„ ì…ë ¥ ì—…ë°ì´íŠ¸
            const globalInputs = [
                'showBackground', 'showGridlines', 'showAxisLabels', 'gridlineInterval',
                'yAxisMin', 'curvedLines', 'fillUnderLine',
                'yAxisMinBar', 'horizontalBars', 'stackedBars', 'showBarValues', 'showPieLabels', 'showPieValues'
            ];
            
            globalInputs.forEach(inputId => {
                const element = document.getElementById(inputId);
                if (element) {
                    element.addEventListener('input', debounce(() => {
                        generateChart();
                    }, 300));
                    element.addEventListener('change', debounce(() => {
                        generateChart();
                    }, 300));
                }
            });
            
            console.log('âœ… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');

            // Also capture settings on any input change so switching types later preserves tweaks
            Array.from(document.querySelectorAll('input, select, textarea')).forEach(el => {
                el.addEventListener('input', debounce(() => {
                    try { captureTypeSettings(chartConfig.type); } catch(e) {}
                }, 200));
            });

        
            // Arrow bars toggle (added)
            const arrowBarsEl = document.getElementById('arrowBars');
            if (arrowBarsEl) {
                const arrowControls = document.getElementById('arrowControls');
                arrowControls.style.display = arrowBarsEl.checked ? 'block' : 'none';
                arrowBarsEl.addEventListener('change', function() {
                    if (arrowControls) arrowControls.style.display = this.checked ? 'block' : 'none';
                    generateChart();
                });
            }
    }
        
        // ê°•ì¡° í•­ëª© ì¶”ê°€
        function addHighlight() {
            highlightCounter++;
            const container = document.getElementById('highlightList');
            const highlightItem = document.createElement('div');
            highlightItem.className = 'highlight-item';
            highlightItem.id = `highlight-${highlightCounter}`;
            
            // í˜„ì¬ ì°¨íŠ¸ íƒ€ì…ì— ë”°ë¥¸ ì‹œë¦¬ì¦ˆ ê°œìˆ˜ í™•ì¸
            let maxSeries = 1;
            let chartTypeName = '';
            
            if (chartConfig.type === 'line') {
                maxSeries = parseInt(document.getElementById('numberOfLines')?.value) || 1;
                chartTypeName = 'ì„ ';
            } else if (chartConfig.type === 'bar') {
                maxSeries = parseInt(document.getElementById('numberOfBars')?.value) || 1;
                chartTypeName = 'ë§‰ëŒ€ ì„¸íŠ¸';
            } else if (chartConfig.type === 'pie') {
                maxSeries = parseInt(document.getElementById('numberOfPies')?.value) || 1;
                chartTypeName = 'íŒŒì´ ì°¨íŠ¸';
            }
            
            let seriesDropdown = '';
            if (maxSeries > 1) {
                let seriesOptions = '';
                for (let i = 1; i <= maxSeries; i++) {
                    seriesOptions += `<option value="${i}">${i}ë²ˆì§¸ ${chartTypeName}</option>`;
                }
                seriesDropdown = `<select style="width: 120px;" oninput="generateChart()">${seriesOptions}</select>`;
            }
            
            highlightItem.innerHTML = `
                ${seriesDropdown}
                <input type="number" placeholder="ìš”ì†Œ ë²ˆí˜¸" min="1" style="width: 100px;" oninput="generateChart()">
                <select oninput="generateChart()">
                    <option value="#f17d38">ì˜¤ë Œì§€</option>
                    <option value="#22cc92">ê·¸ë¦°</option>
                    <option value="#e74c3c">ë ˆë“œ</option>
                    <option value="#9b59b6">í¼í”Œ</option>
                    <option value="#f39c12">ì˜ë¡œìš°</option>
                </select>
                <button type="button" class="btn btn-danger btn-small" onclick="removeHighlight('highlight-${highlightCounter}')">Ã—</button>
            `;
            
            container.appendChild(highlightItem);
        }
        
        // ê°•ì¡° í•­ëª© ì œê±°
        function removeHighlight(id) {
            const item = document.getElementById(id);
            if (item) {
                item.remove();
                generateChart();
            }
        }
        
        // ìŠ¬ë¼ì´ë” ì„¤ì •
        function setupSlider(rangeId, numberId, labelId) {
            const range = document.getElementById(rangeId);
            const number = document.getElementById(numberId);
            const label = document.getElementById(labelId);
            
            if (!range || !number) return;
            
            const updateValue = (value) => {
                range.value = value;
                number.value = value;
                if (label) label.textContent = value;
                generateChart();
            };
            
            range.addEventListener('input', () => updateValue(range.value));
            number.addEventListener('input', () => updateValue(number.value));
        }
        
        // ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // ì°¨íŠ¸ ì˜µì…˜ í‘œì‹œ
        function showChartOptions(chartType) {
            document.querySelectorAll('.chart-options').forEach(option => {
                option.classList.remove('active');
            });
            
            const targetOption = document.getElementById(chartType + 'Options');
            if (targetOption) {
                targetOption.classList.add('active');
            }// ê¸°ì¡´ ì½”ë“œì—ì„œ targetOption ì°¾ëŠ” ë¶€ë¶„ì— ì¶”ê°€
            if (chartType === 'table' && !tableData.length) {
                initializeTableData();
            }
        }
        
        // ê°•ì¡° ë¼ë²¨ ì—…ë°ì´íŠ¸
        function updateHighlightLabel() {
            // ê°•ì¡° ì„¤ì •ì€ ì´ì œ ë™ì ìœ¼ë¡œ ì¶”ê°€/ì œê±°ë˜ë¯€ë¡œ ë ˆì´ë¸”ì€ ì¼ë°˜ì ìœ¼ë¡œ ìœ ì§€
        }
        
        // ì‹œë¦¬ì¦ˆ ì»¨í…Œì´ë„ˆ ì—…ë°ì´íŠ¸
        function updateSeriesContainers() {
            updateLineSeriesContainer();
            updateBarSeriesContainer();
            updatePieSeriesContainer();
        }
        
        // ì„ í˜• ì°¨íŠ¸ ì‹œë¦¬ì¦ˆ ì»¨í…Œì´ë„ˆ ì—…ë°ì´íŠ¸
        function updateLineSeriesContainer() {
            const container = document.getElementById('lineSeriesContainer');
            const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
            const sameStyleCheckbox = document.getElementById('sameStyleCheckbox');
            
            // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
            const preservedData = preserveSeriesData();
            
            // "ê°™ì€ ìŠ¤íƒ€ì¼ ì ìš©" ì²´í¬ë°•ìŠ¤ ìˆ¨ê¸°ê¸°
            sameStyleCheckbox.style.display = 'none';
            
            container.innerHTML = '';
            
            // ì „ì—­ ìŠ¤íƒ€ì¼ ì„¤ì • ì„¹ì…˜ ì¶”ê°€ (ì²« ë²ˆì§¸ì—ë§Œ)
            if (numberOfLines > 0) {
                const globalStyleDiv = document.createElement('div');
                globalStyleDiv.className = 'form-section';
                globalStyleDiv.innerHTML = `
                    <h3>ğŸ” ëª¨ë“  ì„  ê³µí†µ ì„¤ì •</h3>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPointsGlobal" checked oninput="syncGlobalStyle('showPoints'); generateChart()">
                        <label for="showPointsGlobal">í¬ì¸íŠ¸ í‘œì‹œ</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPointStrokeGlobal" checked oninput="syncGlobalStyle('showPointStroke'); generateChart()">
                        <label for="showPointStrokeGlobal">í¬ì¸íŠ¸ í…Œë‘ë¦¬</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPointValuesGlobal" checked oninput="syncGlobalStyle('showPointValues'); generateChart()">
                        <label for="showPointValuesGlobal">í¬ì¸íŠ¸ ìœ„ ìˆ˜ì¹˜</label>
                    </div>
                    
                    <div class="form-group">
                        <label>ì„  êµµê¸°: <span id="lineWidthValueGlobal">15</span>px</label>
                        <div class="slider-group">
                            <input type="range" id="lineWidthGlobal" min="1" max="20" value="15" oninput="updateSliderValue('lineWidthGlobal', 'lineWidthNumGlobal', 'lineWidthValueGlobal'); syncGlobalStyle('lineWidth'); generateChart();">
                            <input type="number" id="lineWidthNumGlobal" min="1" max="20" value="15" oninput="updateSliderValue('lineWidthNumGlobal', 'lineWidthGlobal', 'lineWidthValueGlobal'); syncGlobalStyle('lineWidth'); generateChart();">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>í¬ì¸íŠ¸ í¬ê¸°: <span id="pointSizeValueGlobal">6</span>px</label>
                        <div class="slider-group">
                            <input type="range" id="pointSizeGlobal" min="2" max="30" value="16" oninput="updateSliderValue('pointSizeGlobal', 'pointSizeNumGlobal', 'pointSizeValueGlobal'); syncGlobalStyle('pointSize'); generateChart();">
                            <input type="number" id="pointSizeNumGlobal" min="2" max="30" value="16" oninput="updateSliderValue('pointSizeNumGlobal', 'pointSizeGlobal', 'pointSizeValueGlobal'); syncGlobalStyle('pointSize'); generateChart();">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>í¬ì¸íŠ¸ í…Œë‘ë¦¬ êµµê¸°: <span id="pointStrokeWidthValueGlobal">2</span>px</label>
                        <div class="slider-group">
                            <input type="range" id="pointStrokeWidthGlobal" min="0" max="15" value="9" oninput="updateSliderValue('pointStrokeWidthGlobal', 'pointStrokeWidthNumGlobal', 'pointStrokeWidthValueGlobal'); syncGlobalStyle('pointStrokeWidth'); generateChart();">
                            <input type="number" id="pointStrokeWidthNumGlobal" min="0" max="15" value="9" oninput="updateSliderValue('pointStrokeWidthNumGlobal', 'pointStrokeWidthGlobal', 'pointStrokeWidthValueGlobal'); syncGlobalStyle('pointStrokeWidth'); generateChart();">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>ìˆ˜ì¹˜ í…ìŠ¤íŠ¸ í¬ê¸°: <span id="lineValueFontSizeValue">55</span>px</label>
                        <div class="slider-group">
                            <input type="range" id="lineValueFontSizeGlobal" min="12" max="100" value="55" oninput="updateSliderValue('lineValueFontSizeGlobal', 'lineValueFontSizeNumGlobal', 'lineValueFontSizeValue'); generateChart();">
                            <input type="number" id="lineValueFontSizeNumGlobal" min="12" max="100" value="55" oninput="updateSliderValue('lineValueFontSizeNumGlobal', 'lineValueFontSizeGlobal', 'lineValueFontSizeValue'); generateChart();">
                        </div>
                    </div>
                `;
                container.appendChild(globalStyleDiv);
            }
            
            for (let i = 0; i < numberOfLines; i++) {
                const seriesDiv = document.createElement('div');
                seriesDiv.className = 'series-container';
                
                seriesDiv.innerHTML = `
                    <div class="series-header">
                        <div class="series-title">ì„  ${i + 1} ìƒ‰ìƒ ì„¤ì •</div>
                    </div>
                    
                    <div class="form-group">
                        <label>ë°ì´í„° ê°’</label>
                        <input type="text" id="lineData${i}" placeholder="ì˜ˆ: 10, 20, 15, 30, 25" value="10, 20, 15, 30, 25" oninput="generateChart()">
                    </div>
                    
                    <div class="form-group">
                        <label>ë ˆì´ë¸” (ì²« ë²ˆì§¸ ì„ ì—ë§Œ ì ìš©)</label>
                        <input type="text" id="lineLabels${i}" placeholder="ì˜ˆ: 1ì›”, 2ì›”, 3ì›”, 4ì›”, 5ì›”" value="1ì›”, 2ì›”, 3ì›”, 4ì›”, 5ì›”" oninput="generateChart()" ${i > 0 ? 'disabled' : ''}>
                    </div>
                    
                    <div class="form-group">
                        <label>ì„ &í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒ</label>
                        <input type="color" id="lineColor${i}" value="${colorPalette[i % colorPalette.length]}" oninput="syncLineAndStrokeColor(${i})">
                    </div>
                    
                    <div class="form-group">
                        <label>í¬ì¸íŠ¸ ìƒ‰ìƒ</label>
                        <input type="color" id="pointColor${i}" value="#FFFFFF" oninput="generateChart()">
                    </div>
                    
                    <!-- ìˆ¨ê²¨ì§„ ì…ë ¥ í•„ë“œë“¤ (í˜¸í™˜ì„± ìœ ì§€ìš©) -->
                    <input type="color" id="pointStrokeColor${i}" value="${colorPalette[i % colorPalette.length]}" style="display: none;">
                    <input type="checkbox" id="showPoints${i}" checked style="display: none;">
                    <input type="checkbox" id="showPointStroke${i}" checked style="display: none;">
                    <input type="checkbox" id="showPointValues${i}" checked style="display: none;">
                    <input type="range" id="lineWidth${i}" min="1" max="20" value="2" style="display: none;">
                    <input type="number" id="lineWidthNum${i}" min="1" max="20" value="15" style="display: none;">
                    <input type="range" id="pointSize${i}" min="2" max="30" value="6" style="display: none;">
                    <input type="number" id="pointSizeNum${i}" min="2" max="30" value="6" style="display: none;">
                    <input type="range" id="pointStrokeWidth${i}" min="0" max="15" value="2" style="display: none;">
                    <input type="number" id="pointStrokeWidthNum${i}" min="0" max="15" value="2" style="display: none;">
                `;
                
                container.appendChild(seriesDiv);
            }
            
            // ë³´ì¡´ëœ ë°ì´í„° ë³µì›
            restoreSeriesData(preservedData);
            
            // ëª¨ë“  ì‹œë¦¬ì¦ˆì˜ ìƒ‰ìƒ ë™ê¸°í™” ì„¤ì •
            for (let i = 0; i < numberOfLines; i++) {
                const lineColorInput = document.getElementById(`lineColor${i}`);
                const pointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
                
                if (lineColorInput && pointStrokeColorInput) {
                    // í•­ìƒ ì„  ìƒ‰ìƒê³¼ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒ ë™ê¸°í™”
                    pointStrokeColorInput.value = lineColorInput.value;
                }
            }
            
            // ì „ì—­ ì„¤ì •ì„ ê°œë³„ ì„¤ì •ì— ì ìš©
            syncGlobalStyle('showPoints');
            syncGlobalStyle('showPointStroke');
            syncGlobalStyle('showPointValues');
            syncGlobalStyle('lineWidth');
            syncGlobalStyle('pointSize');
            syncGlobalStyle('pointStrokeWidth');
            
            // ê° ì„ ì˜ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒì„ í•´ë‹¹ ì„ ì˜ ìƒ‰ìƒìœ¼ë¡œ ë‹¤ì‹œ ì„¤ì •
            for (let i = 0; i < numberOfLines; i++) {
                const lineColorInput = document.getElementById(`lineColor${i}`);
                const pointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
                
                if (lineColorInput && pointStrokeColorInput) {
                    pointStrokeColorInput.value = lineColorInput.value;
                }
            }
        }
        // ë°” ì°¨íŠ¸ ë°ì´í„° ë³´ì¡´ í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
        function preserveBarSeriesData() {
            const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
            const preservedData = {};
            
            // ê¸°ì¡´ ë°ì´í„° ì €ì¥
            for (let i = 0; i < 10; i++) { // ìµœëŒ€ 10ê°œê¹Œì§€ í™•ì¸
                const dataInput = document.getElementById(`barData${i}`);
                const labelsInput = document.getElementById(`barLabels${i}`);
                const barColorInput = document.getElementById(`barColor${i}`);
                const useIndividualColorsInput = document.getElementById(`useIndividualBarColors${i}`);
                
                if (dataInput || labelsInput || barColorInput || useIndividualColorsInput) {
                    preservedData[i] = {
                        data: dataInput ? dataInput.value : '',
                        labels: labelsInput ? labelsInput.value : '',
                        barColor: barColorInput ? barColorInput.value : '',
                        useIndividualColors: useIndividualColorsInput ? useIndividualColorsInput.checked : false,
                        individualColors: {}
                    };
                    
                    // ê°œë³„ ìƒ‰ìƒë“¤ë„ ì €ì¥
                    if (dataInput && dataInput.value) {
                        const dataValues = parseData(dataInput.value);
                        for (let j = 0; j < dataValues.length; j++) {
                            const individualColorInput = document.getElementById(`individualBarColor${i}_${j}`);
                            if (individualColorInput) {
                                preservedData[i].individualColors[j] = individualColorInput.value;
                            }
                        }
                    }
                }
            }
            
            return preservedData;
        }
        
        // ë°” ì°¨íŠ¸ ë°ì´í„° ë³µì› í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
        function restoreBarSeriesData(preservedData) {
            Object.keys(preservedData).forEach(index => {
                const i = parseInt(index);
                const data = preservedData[i];
                
                // ê¸°ë³¸ ì„¤ì • ë³µì›
                const dataInput = document.getElementById(`barData${i}`);
                const labelsInput = document.getElementById(`barLabels${i}`);
                const barColorInput = document.getElementById(`barColor${i}`);
                const useIndividualColorsInput = document.getElementById(`useIndividualBarColors${i}`);
                
                if (dataInput && data.data) dataInput.value = data.data;
                if (labelsInput && data.labels) labelsInput.value = data.labels;
                if (barColorInput && data.barColor) barColorInput.value = data.barColor;
                if (useIndividualColorsInput && data.hasOwnProperty('useIndividualColors')) {
                    useIndividualColorsInput.checked = data.useIndividualColors;
                    // ê°œë³„ ìƒ‰ìƒ ì»¨í…Œì´ë„ˆ í‘œì‹œ/ìˆ¨ê¹€ ì—…ë°ì´íŠ¸
                    toggleIndividualBarColors(i);
                }
                
                // ê°œë³„ ìƒ‰ìƒë“¤ ë³µì›
                Object.keys(data.individualColors).forEach(colorIndex => {
                    const j = parseInt(colorIndex);
                    const individualColorInput = document.getElementById(`individualBarColor${i}_${j}`);
                    if (individualColorInput) {
                        individualColorInput.value = data.individualColors[j];
                    }
                });
            });
        }
        
        function updateBarSeriesContainer() {
    const container = document.getElementById('barSeriesContainer');
    const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
    
    // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
    const preservedData = preserveBarSeriesData();
    
    container.innerHTML = '';
            
            for (let i = 0; i < numberOfBars; i++) {
                const seriesDiv = document.createElement('div');
                seriesDiv.className = 'series-container';
                seriesDiv.innerHTML = `
                    <div class="series-header">
                        <div class="series-title">ë§‰ëŒ€ ì„¸íŠ¸ ${i + 1}</div>
                    </div>
                    
                    <div class="form-group">
                        <label>ë°ì´í„° ê°’</label>
                        <input type="text" id="barData${i}" placeholder="ì˜ˆ: 15, 25, 20, 35, 30" value="${preservedData[i]?.data || '15, 25, 20, 35, 30'}" oninput="updateIndividualBarColors(${i}); generateChart()">
                    </div>
                    
                    <div class="form-group">
                        <label>ë ˆì´ë¸” (ì²« ë²ˆì§¸ ì„¸íŠ¸ì—ë§Œ ì ìš©)</label>
                        <input type="text" id="barLabels${i}" placeholder="ì˜ˆ: A, B, C, D, E" value="${preservedData[i]?.labels || 'A, B, C, D, E'}" oninput="generateChart()" ${i > 0 ? 'disabled' : ''}>
                    </div>
                    
                    <div class="form-group">
                        <label>ë§‰ëŒ€ ìƒ‰ìƒ</label>
                        <input type="color" id="barColor${i}" value="${preservedData[i]?.barColor || colorPalette[i % colorPalette.length]}" oninput="generateChart()">
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="useIndividualBarColors${i}" oninput="toggleIndividualBarColors(${i}); generateChart();">
                        <label for="useIndividualBarColors${i}">ê° ë§‰ëŒ€ë§ˆë‹¤ ë‹¤ë¥¸ ìƒ‰ìƒ</label>
                    </div>
                    
                    <div id="individualBarColorsContainer${i}" class="individual-bar-colors" style="display: none;">
                        <h4>ë§‰ëŒ€ë³„ ìƒ‰ìƒ ì„¤ì •</h4>
                        <div id="individualBarColorsList${i}">
                            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                        </div>
                    </div>
                `;
                
                container.appendChild(seriesDiv);
                updateIndividualBarColors(i);
            }

            // ë³´ì¡´ëœ ë°ì´í„° ë³µì› (ì—¬ê¸°ì— ì¶”ê°€)
    restoreBarSeriesData(preservedData);
    
    // ê° ì‹œë¦¬ì¦ˆì˜ ê°œë³„ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ (ì—¬ê¸°ì— ì¶”ê°€)
    for (let i = 0; i < numberOfBars; i++) {
        updateIndividualBarColors(i);
    }
            
}
        
        // ê°œë³„ ë§‰ëŒ€ ìƒ‰ìƒ í† ê¸€ í•¨ìˆ˜
        function toggleIndividualBarColors(seriesIndex) {
            const checkbox = document.getElementById(`useIndividualBarColors${seriesIndex}`);
            const container = document.getElementById(`individualBarColorsContainer${seriesIndex}`);
            
            if (checkbox && container) {
                container.style.display = checkbox.checked ? 'block' : 'none';
                if (checkbox.checked) {
                    updateIndividualBarColors(seriesIndex);
                }
            }
        }
        
        // ê°œë³„ ë§‰ëŒ€ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateIndividualBarColors(seriesIndex) {
            const dataInput = document.getElementById(`barData${seriesIndex}`);
            const colorsList = document.getElementById(`individualBarColorsList${seriesIndex}`);
            
            if (!dataInput || !colorsList) return;
            
            const data = parsePieData(dataInput.value);
            colorsList.innerHTML = '';
            
            if (data.length > 0) {
                data.forEach((value, index) => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'color-item';
                    colorDiv.innerHTML = `
                        <span>ë§‰ëŒ€ ${index + 1} (ê°’: ${value})</span>
                        <input type="color" id="individualBarColor${seriesIndex}_${index}" value="${colorPalette[index % colorPalette.length]}" oninput="generateChart()">
                    `;
                    colorsList.appendChild(colorDiv);
                });
            }
        }
        
        // ìŠ¤íƒ€ì¼ ì„¤ì • ë™ê¸°í™” í•¨ìˆ˜
        function syncStyleSettings(sourceIndex, settingType) {
            const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
            const useSameStyle = document.getElementById('useSameStyle')?.checked;
            
            // ê°™ì€ ìŠ¤íƒ€ì¼ ì ìš©ì´ ì²´í¬ë˜ì–´ ìˆê³ , ì²« ë²ˆì§¸ ì„ ì—ì„œ ë³€ê²½ë  ê²½ìš°ì—ë§Œ ë™ê¸°í™”
            // pointStrokeColorëŠ” ê° ì„ ì˜ ìƒ‰ìƒê³¼ ì—°ë™ë˜ì–´ì•¼ í•˜ë¯€ë¡œ ë™ê¸°í™”ì—ì„œ ì œì™¸
            if (useSameStyle && sourceIndex === 0 && numberOfLines > 1 && settingType !== 'pointStrokeColor') {
                const sourceElement = document.getElementById(`${settingType}${sourceIndex}`);
                const sourceValue = sourceElement ? sourceElement.value : null;
                const sourceChecked = sourceElement ? sourceElement.checked : null;
                
                for (let i = 1; i < numberOfLines; i++) {
                    const targetElement = document.getElementById(`${settingType}${i}`);
                    if (targetElement) {
                        if (targetElement.type === 'checkbox') {
                            targetElement.checked = sourceChecked;
                        } else {
                            targetElement.value = sourceValue;
                            
                            // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
                            if (settingType.includes('lineWidth')) {
                                updateSliderValue(`${settingType}${i}`, `${settingType}Num${i}`, `${settingType}Value${i}`);
                            } else if (settingType.includes('pointSize')) {
                                updateSliderValue(`${settingType}${i}`, `${settingType}Num${i}`, `${settingType}Value${i}`);
                            } else if (settingType.includes('pointStrokeWidth')) {
                                updateSliderValue(`${settingType}${i}`, `${settingType}Num${i}`, `${settingType}Value${i}`);
                            }
                        }
                    }
                }
            }
        }
        // ìƒ‰ìƒ ë™ê¸°í™” í† ê¸€ í•¨ìˆ˜
        function toggleColorSync(seriesIndex) {
            const checkbox = document.getElementById(`syncColors${seriesIndex}`);
            const lineColorInput = document.getElementById(`lineColor${seriesIndex}`);
            const pointStrokeColorInput = document.getElementById(`pointStrokeColor${seriesIndex}`);
            const pointStrokeColorGroup = document.getElementById(`pointStrokeColorGroup${seriesIndex}`);
            
            if (checkbox && lineColorInput && pointStrokeColorInput && pointStrokeColorGroup) {
                if (checkbox.checked) {
                    // ë¶„ë¦¬ ëª¨ë“œ: í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒì„ ë³„ë„ë¡œ ì„¤ì • ê°€ëŠ¥
                    pointStrokeColorGroup.style.display = 'block';
                } else {
                    // ë™ê¸°í™” ëª¨ë“œ: í•´ë‹¹ ì„  ìƒ‰ìƒê³¼ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒ ë™ê¸°í™”
                    pointStrokeColorGroup.style.display = 'none';
                    pointStrokeColorInput.value = lineColorInput.value;
                }
                
                // ê°™ì€ ìŠ¤íƒ€ì¼ ì ìš©ì´ í™œì„±í™”ëœ ê²½ìš° ë‹¤ë¥¸ ì‹œë¦¬ì¦ˆë„ ë™ê¸°í™”
                const useSameStyle = document.getElementById('useSameStyle')?.checked;
                const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
                
                if (useSameStyle && seriesIndex === 0 && numberOfLines > 1) {
                    for (let i = 1; i < numberOfLines; i++) {
                        const targetCheckbox = document.getElementById(`syncColors${i}`);
                        const targetLineColorInput = document.getElementById(`lineColor${i}`);
                        const targetPointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
                        const targetPointStrokeColorGroup = document.getElementById(`pointStrokeColorGroup${i}`);
                        
                        if (targetCheckbox && targetLineColorInput && targetPointStrokeColorInput && targetPointStrokeColorGroup) {
                            targetCheckbox.checked = checkbox.checked;
                            if (checkbox.checked) {
                                targetPointStrokeColorGroup.style.display = 'block';
                            } else {
                                targetPointStrokeColorGroup.style.display = 'none';
                                // ê° ì„ ì˜ ìƒ‰ìƒê³¼ í•´ë‹¹ ì„ ì˜ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒ ë™ê¸°í™”
                                targetPointStrokeColorInput.value = targetLineColorInput.value;
                            }
                        }
                    }
                }
            }
        }
        // ì „ì—­ ìŠ¤íƒ€ì¼ ë™ê¸°í™” í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
        function syncGlobalStyle(settingType) {
    const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
    const globalElement = document.getElementById(`${settingType}Global`);
    
    if (!globalElement) return;
    
    // pointStrokeColorëŠ” ì „ì—­ ë™ê¸°í™”ì—ì„œ ì œì™¸ (ê° ì„ ë§ˆë‹¤ ë‹¤ë¥¸ ìƒ‰ìƒì„ ìœ ì§€í•´ì•¼ í•¨)
    if (settingType === 'pointStrokeColor') return;
    
    const globalValue = globalElement.type === 'checkbox' ? globalElement.checked : globalElement.value;
    
    for (let i = 0; i < numberOfLines; i++) {
        const targetElement = document.getElementById(`${settingType}${i}`);
        if (targetElement) {
            if (targetElement.type === 'checkbox') {
                targetElement.checked = globalValue;
            } else {
                targetElement.value = globalValue;
                
                // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
                if (settingType.includes('lineWidth')) {
                    updateSliderValue(`${settingType}${i}`, `${settingType}Num${i}`, `${settingType}Value${i}`);
                } else if (settingType.includes('pointSize')) {
                    updateSliderValue(`${settingType}${i}`, `${settingType}Num${i}`, `${settingType}Value${i}`);
                } else if (settingType.includes('pointStrokeWidth')) {
                    updateSliderValue(`${settingType}${i}`, `${settingType}Num${i}`, `${settingType}Value${i}`);
                }
            }
        }
    }
}
        
        // ì„  ìƒ‰ìƒ ë³€ê²½ ì‹œ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒë„ ë™ê¸°í™”
function syncLineAndStrokeColor(seriesIndex) {
    const lineColorInput = document.getElementById(`lineColor${seriesIndex}`);
    const pointStrokeColorInput = document.getElementById(`pointStrokeColor${seriesIndex}`);
    
    // í•´ë‹¹ ì„ ì˜ ì„  ìƒ‰ìƒê³¼ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒ ë™ê¸°í™”
    if (lineColorInput && pointStrokeColorInput) {
        pointStrokeColorInput.value = lineColorInput.value;
    }
    
    generateChart();
}
        
        // ì„  ê°œìˆ˜ ë³€ê²½ ì‹œ ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
        function preserveSeriesData() {
            const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
            const preservedData = {};
            
            // ê¸°ì¡´ ë°ì´í„° ì €ì¥
            for (let i = 0; i < 10; i++) { // ìµœëŒ€ 10ê°œê¹Œì§€ í™•ì¸
                const dataInput = document.getElementById(`lineData${i}`);
                const labelsInput = document.getElementById(`lineLabels${i}`);
                const lineColorInput = document.getElementById(`lineColor${i}`);
                const pointColorInput = document.getElementById(`pointColor${i}`);
                if (dataInput || labelsInput || lineColorInput || pointColorInput) {
                    preservedData[i] = {
                        data: dataInput ? dataInput.value : '',
                        labels: labelsInput ? labelsInput.value : '',
                        lineColor: lineColorInput ? lineColorInput.value : '',
                        pointColor: pointColorInput ? pointColorInput.value : ''
                    };
                    
                    // ìŠ¤íƒ€ì¼ ì„¤ì • ì €ì¥
                    const styleSettings = ['showPoints', 'showPointStroke', 'showPointValues', 'lineWidth', 'pointSize', 'pointStrokeWidth', 'pointStrokeColor'];
                    styleSettings.forEach(setting => {
                        const element = document.getElementById(`${setting}${i}`);
                        if (element) {
                            if (element.type === 'checkbox') {
                                preservedData[i][setting] = element.checked;
                            } else {
                                preservedData[i][setting] = element.value;
                            }
                        }
                    });
                }
            }
            
            return preservedData;
        }
        
        // ë³´ì¡´ëœ ë°ì´í„° ë³µì›
        function restoreSeriesData(preservedData) {
            Object.keys(preservedData).forEach(index => {
                const i = parseInt(index);
                const data = preservedData[i];
                
                // ê¸°ë³¸ ì„¤ì • ë³µì›
                const dataInput = document.getElementById(`lineData${i}`);
                const labelsInput = document.getElementById(`lineLabels${i}`);
                const lineColorInput = document.getElementById(`lineColor${i}`);
                const pointColorInput = document.getElementById(`pointColor${i}`);
                const syncColorsInput = document.getElementById(`syncColors${i}`);
                
                if (dataInput && data.data) dataInput.value = data.data;
                if (labelsInput && data.labels) labelsInput.value = data.labels;
                if (lineColorInput && data.lineColor) lineColorInput.value = data.lineColor;
                if (pointColorInput && data.pointColor) pointColorInput.value = data.pointColor;
                // í•­ìƒ ì„  ìƒ‰ìƒê³¼ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒ ë™ê¸°í™” (ë³µì› í›„)
                const pointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
                if (pointStrokeColorInput && lineColorInput) {
                    pointStrokeColorInput.value = lineColorInput.value;
                }
                
                // ìŠ¤íƒ€ì¼ ì„¤ì • ë³µì›
                const styleSettings = ['showPoints', 'showPointStroke', 'showPointValues', 'lineWidth', 'pointSize', 'pointStrokeWidth', 'pointStrokeColor'];
                styleSettings.forEach(setting => {
                    const element = document.getElementById(`${setting}${i}`);
                    if (element && data.hasOwnProperty(setting)) {
                        if (element.type === 'checkbox') {
                            element.checked = data[setting];
                        } else {
                            element.value = data[setting];
                            
                            // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
                            if (setting.includes('lineWidth')) {
                                updateSliderValue(`${setting}${i}`, `${setting}Num${i}`, `${setting}Value${i}`);
                            } else if (setting.includes('pointSize')) {
                                updateSliderValue(`${setting}${i}`, `${setting}Num${i}`, `${setting}Value${i}`);
                            } else if (setting.includes('pointStrokeWidth')) {
                                updateSliderValue(`${setting}${i}`, `${setting}Num${i}`, `${setting}Value${i}`);
                            }
                        }
                    }
                });
            });
            // ë³µì› í›„ ê° ì„ ì˜ í¬ì¸íŠ¸ í…Œë‘ë¦¬ ìƒ‰ìƒì„ í•´ë‹¹ ì„  ìƒ‰ìƒìœ¼ë¡œ ë™ê¸°í™” (ì—¬ê¸°ì— ì¶”ê°€)
    Object.keys(preservedData).forEach(index => {
        const i = parseInt(index);
        const lineColorInput = document.getElementById(`lineColor${i}`);
        const pointStrokeColorInput = document.getElementById(`pointStrokeColor${i}`);
        
        if (lineColorInput && pointStrokeColorInput) {
            pointStrokeColorInput.value = lineColorInput.value;
        }
    });
        }
        
        // íŒŒì´ ì°¨íŠ¸ ì‹œë¦¬ì¦ˆ ì»¨í…Œì´ë„ˆ ì—…ë°ì´íŠ¸
        function updatePieSeriesContainer() {
            const container = document.getElementById('pieSeriesContainer');
            const numberOfPies = parseInt(document.getElementById('numberOfPies')?.value) || 1;
            
            container.innerHTML = '';
            
            for (let i = 0; i < numberOfPies; i++) {
                const pieDiv = document.createElement('div');
                pieDiv.className = 'pie-container';
                pieDiv.innerHTML = `
                    <div class="series-header">
                        <div class="series-title">íŒŒì´ ì°¨íŠ¸ ${i + 1}</div>
                    </div>
                    
                    <div class="form-group">
                        <label>ë°ì´í„° ê°’</label>
                        <input type="text" id="pieData${i}" placeholder="ì˜ˆ: 25, 30, 45" value="25, 30, 45" oninput="updatePieColors(${i}); generateChart();">
                    </div>
                    
                    <div class="form-group">
                        <label>ë ˆì´ë¸”</label>
                        <input type="text" id="pieLabels${i}" placeholder="ì˜ˆ: ê·¸ë£¹1, ê·¸ë£¹2, ê·¸ë£¹3" value="ê·¸ë£¹1, ê·¸ë£¹2, ê·¸ë£¹3" oninput="generateChart()">
                    </div>
                    
                    <div class="checkbox-group">
    <input type="checkbox" id="isDonut${i}" checked oninput="toggleDonutThickness(${i}); generateChart();">
    <label for="isDonut${i}">ë„ë„› ì°¨íŠ¸</label>
</div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="isHalfPie${i}" oninput="generateChart();">
                        <label for="isHalfPie${i}">ë°˜ì› ì°¨íŠ¸ (Half Pie)</label>
                    </div>
                    
                    <div class="form-group" id="donutThicknessContainer${i}" style="display: block;">
    <label>ë„ë„› ë‘ê»˜: <span id="donutThicknessValue${i}">40</span>%</label>
    <input type="range" id="donutThickness${i}" min="20" max="80" value="40" oninput="document.getElementById('donutThicknessValue${i}').textContent = this.value; generateChart();">
</div>
                    
                    <div id="pieColorContainer${i}">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                `;
                
                container.appendChild(pieDiv);
                updatePieColors(i);
            }
        }
        
        // íŒŒì´ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
        function updatePieColors(pieIndex) {
            const container = document.getElementById(`pieColorContainer${pieIndex}`);
            const dataInput = document.getElementById(`pieData${pieIndex}`);
            
            if (!container || !dataInput) return;
            
            const data = parsePieData(dataInput.value);
            container.innerHTML = '';
            
            if (data.length > 0) {
                const title = document.createElement('h4');
                title.textContent = 'ì¡°ê°ë³„ ìƒ‰ìƒ';
                title.style.marginBottom = '10px';
                container.appendChild(title);
                
                data.forEach((value, index) => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'color-item';
                    colorDiv.innerHTML = `
                        <span>ì¡°ê° ${index + 1} (${value})</span>
                        <input type="color" id="pieColor${pieIndex}_${index}" value="${pieColorPalette[index % pieColorPalette.length]}" oninput="generateChart()">
                    `;
                    container.appendChild(colorDiv);
                });
            }
        }
        
        // ë„ë„› ë‘ê»˜ í† ê¸€
        function toggleDonutThickness(pieIndex) {
            const checkbox = document.getElementById(`isDonut${pieIndex}`);
            const container = document.getElementById(`donutThicknessContainer${pieIndex}`);
            container.style.display = checkbox.checked ? 'block' : 'none';
        }
        
// íŒŒì´ ì°¨íŠ¸ìš© ë°ì´í„° íŒŒì‹± (x ìë™ ê³„ì‚° ì§€ì› + í•œê¸€ ìˆ«ì)
function parsePieData(dataString) {
    if (!dataString || dataString.trim() === '') return [];
    
    const separators = /[,\s%|;\t]+/;
    const rawData = dataString.split(separators)
        .map(d => d.trim())
        .filter(d => d);
    
    // ìˆ«ì ê°’ê³¼ x ê°’ ë¶„ë¦¬
    const numbers = [];
    let hasX = false;
    
    rawData.forEach(item => {
        if (item.toLowerCase() === 'x') {
            hasX = true;
            numbers.push('x'); // xì˜ ìœ„ì¹˜ ë³´ì¡´
        } else {
            const num = parseKoreanMixedNumber(item);
            if (!isNaN(num)) {
                numbers.push(num);
            }
        }
    });
    
    // xê°€ ìˆìœ¼ë©´ ìë™ ê³„ì‚°
    if (hasX) {
        const numericValues = numbers.filter(n => n !== 'x');
        const sum = numericValues.reduce((total, val) => total + val, 0);
        const calculatedX = Math.max(0, 100 - sum); // ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡ ë³´ì •
        
        // xë¥¼ ê³„ì‚°ëœ ê°’ìœ¼ë¡œ êµì²´
        const result = numbers.map(item => item === 'x' ? calculatedX : item);
        
        // ì‚¬ìš©ìì—ê²Œ ê³„ì‚° ê²°ê³¼ ì•Œë¦¼
        showStatus(`ğŸ’¡ x = ${calculatedX} (100 - ${sum} = ${calculatedX})`, 'success');
        
        return result;
    }
    
    return numbers;
}
        
        // ë°ì´í„° íŒŒì‹± (ë‹¤ì–‘í•œ êµ¬ë¶„ì ì§€ì› + í•œê¸€ ìˆ«ì)
function parseData(dataString) {
    if (!dataString || dataString.trim() === '') return [];
    
    const separators = /[,\s%|;\t]+/;
    return dataString.split(separators)
        .map(d => parseKoreanMixedNumber(d.trim()))
        .filter(d => !isNaN(d));
}



// === Added helpers to preserve original (Korean) value strings in labels ===
function __splitToTokens(raw) {
    const sep = /[\,\|\t\s]+/;
    return (raw || '').split(sep).map(s => s.trim()).filter(Boolean);
}
function getDisplayValue(type, seriesIndex, dataIndex, numericValue) {
    try {
        let id = null;
        if (type === 'bar') id = `barData${seriesIndex}`;
        else if (type === 'line') id = `lineData${seriesIndex}`;
        else if (type === 'pie') id = `pieData${seriesIndex}`;
        if (!id) return String(numericValue);
        const el = document.getElementById(id);
        if (!el) return String(numericValue);

        // âœ… íŒŒì´ë§Œ parsePieDataë¥¼ ì‚¬ìš©í•´ 'x'ê°€ ìˆ«ìë¡œ ê³„ì‚°ëœ ê²°ê³¼ë¥¼ í‘œì‹œ
        if (type === 'pie') {
            const parsed = (typeof parsePieData === 'function') ? parsePieData(el.value) : [];
            if (Array.isArray(parsed) && dataIndex >= 0 && dataIndex < parsed.length) {
                return String(parsed[dataIndex]);
            }
            return String(numericValue);
        }

        // ì„ /ë§‰ëŒ€ëŠ” ê¸°ì¡´ì²˜ëŸ¼ ì›ë³¸ í† í° ìœ ì§€ (í•œê¸€ ìˆ«ì ë“± ê·¸ëŒ€ë¡œ í‘œê¸° ëª©ì )
        const tokens = __splitToTokens(el.value);
        if (dataIndex >= 0 && dataIndex < tokens.length) return tokens[dataIndex];
        return String(numericValue);
    } catch (e) {
        return String(numericValue);
    }
}
// ==========================================================================
// í•œê¸€+ìˆ«ì í˜¼í•© í‘œê¸°ë¥¼ ì•„ë¼ë¹„ì•„ ìˆ«ìë¡œ ë³€í™˜
function parseKoreanMixedNumber(raw) {
    if (raw == null) return NaN;

    // 1) ì •ê·œí™”
    let s = String(raw)
        .replace(/[,\s]/g, "")                    // ì½¤ë§ˆ/ê³µë°± ì œê±°
        .replace(/[ì•½ì—¬ì¯¤ê°€ëŸ‰ëŒ€Â±~]/g, "")         // í”í•œ ìˆ˜ì‹ì–´ ì œê±°
        .replace(/[ì›ëª…ê±´ê°œíšŒê°€êµ¬ëŒ€kmKmKM%]+$/g, "") // í”í•œ ì ‘ë¯¸ ë‹¨ìœ„ ì œê±°
        .replace(/[âˆ’â€“â€”]/g, "-")                   // ìœ ë‹ˆì½”ë“œ ë§ˆì´ë„ˆìŠ¤ í†µì¼
        .replace(/ë¥™/g, "ìœ¡");                    // 'ë¥™' -> 'ìœ¡' í†µì¼

    // í•œê¸€ ìˆ«ì -> ì•„ë¼ë¹„ì•„ ìˆ«ì ì¹˜í™˜ (ì‹­/ë°±/ì²œ/ë§Œ/ì–µ/ì¡°ëŠ” ê·¸ëŒ€ë¡œ)
    const digitMap = {
        "ê³µ": "0", "ì˜": "0",
        "ì¼": "1", "ì´": "2", "ì‚¼": "3", "ì‚¬": "4",
        "ì˜¤": "5", "ìœ¡": "6", "ì¹ ": "7", "íŒ”": "8", "êµ¬": "9",
    };
    s = s.replace(/[ê³µì˜ì¼ì´ì‚¼ì‚¬ì˜¤ìœ¡ì¹ íŒ”êµ¬]/g, (ch) => digitMap[ch]);

    // ë¶€í˜¸
    let sign = 1;
    if (s.startsWith("+")) s = s.slice(1);
    else if (s.startsWith("-")) { sign = -1; s = s.slice(1); }

    // 2) í° ë‹¨ìœ„ ë¶„í•´(ì¡°, ì–µ, ë§Œ ìˆœì„œ)
    const largeUnits = [
        ["ì¡°", 1e12],
        ["ì–µ", 1e8],
        ["ë§Œ", 1e4],
    ];

    let total = 0;

    for (const [unit, factor] of largeUnits) {
        const idx = s.indexOf(unit);
        if (idx !== -1) {
            const left = s.slice(0, idx);
            const leftVal = left === "" ? 1 : parseSection(left); // 'ë§Œ'ì²˜ëŸ¼ ì• ìˆ«ì ìƒëµ ì‹œ 1
            total += leftVal * factor;
            s = s.slice(idx + unit.length);
        }
    }

    // ë‚¨ì€ í•˜ìœ„ ë‹¨ìœ„ ì²˜ë¦¬(ì²œ/ë°±/ì‹­ + ë§¨ ë ìˆ«ì)
    total += parseSection(s);

    return sign * total;

    // ì„¹ì…˜ íŒŒì„œ: "ì´ë°±ì‹­ì‚¬" ê°™ì€ ì—°ì†ëœ í•œê¸€ ìˆ«ìë¥¼ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬
// ì„¹ì…˜ íŒŒì„œ: "ì´ë°±ì‹­ì‚¬" ê°™ì€ ì—°ì†ëœ í•œê¸€ ìˆ«ìë¥¼ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬
function parseSection(section) {
    if (!section) return 0;
    
    const digitMap = {
        "ì¼": 1, "ì´": 2, "ì‚¼": 3, "ì‚¬": 4, "ì˜¤": 5, 
        "ìœ¡": 6, "ì¹ ": 7, "íŒ”": 8, "êµ¬": 9
    };
    
    let result = 0;
    let current = 0;
    
    // ë¨¼ì € ì•„ë¼ë¹„ì•„ ìˆ«ì + ë‹¨ìœ„ ì²˜ë¦¬
    const arabicUnitRe = /([0-9]+(?:\.[0-9]+)?)?([ì²œë°±ì‹­])/g;
    let rest = section.replace(arabicUnitRe, (match, num, unit) => {
        const n = (num == null || num === "") ? 1 : parseFloat(num);
        const unitVal = { "ì²œ": 1000, "ë°±": 100, "ì‹­": 10 }[unit];
        result += n * unitVal;
        return "";
    });
    
    // í•œê¸€ ìˆ«ì ìˆœì°¨ ì²˜ë¦¬
    for (let i = 0; i < rest.length; i++) {
        const char = rest[i];
        
        if (char === "ì²œ") {
            result += (current || 1) * 1000;
            current = 0;
        } else if (char === "ë°±") {
            result += (current || 1) * 100;
            current = 0;
        } else if (char === "ì‹­") {
            result += (current || 1) * 10;
            current = 0;
        } else if (digitMap[char]) {
            current = current * 10 + digitMap[char];
        }
    }
    
    // ë‚¨ì€ ì¼ì˜ ìë¦¬ ìˆ«ì ì¶”ê°€
    result += current;
    
    // ë‚¨ì€ ì•„ë¼ë¹„ì•„ ìˆ«ì ì²˜ë¦¬
    const remainingNumbers = rest.replace(/[ì¼ì´ì‚¼ì‚¬ì˜¤ìœ¡ì¹ íŒ”êµ¬ì²œë°±ì‹­]/g, "").trim();
    if (remainingNumbers) {
        const v = parseFloat(remainingNumbers);
        if (!isNaN(v)) result += v;
    }
    
    return result;
}
}

// ìˆ«ìë¥¼ ì™„ì „í•œ í•œê¸€ í‘œê¸°ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
function numberToKorean(num) {
    if (num === 0) return "0";
    
    const isNegative = num < 0;
    num = Math.abs(num);
    
    // ì†Œìˆ˜ì ì´ ìˆìœ¼ë©´ í˜¼í•© ë³€í™˜ ì•ˆí•¨
    if (!Number.isInteger(num)) return (isNegative ? "-" : "") + num.toString();
    
    const units = ["", "ë§Œ", "ì–µ", "ì¡°"];
    const digitToKorean = {
        1: "ì¼", 2: "ì´", 3: "ì‚¼", 4: "ì‚¬", 5: "ì˜¤",
        6: "ìœ¡", 7: "ì¹ ", 8: "íŒ”", 9: "êµ¬"
    };
    
    let result = "";
    let unitIndex = 0;
    
    while (num > 0) {
        const part = num % 10000;
        if (part > 0) {
            let partStr = "";
            
            // ì²œì˜ ìë¦¬
            const thousand = Math.floor(part / 1000);
            if (thousand > 0) {
                partStr += (thousand === 1 ? "" : digitToKorean[thousand]) + "ì²œ";
            }
            
            // ë°±ì˜ ìë¦¬
            const hundred = Math.floor((part % 1000) / 100);
            if (hundred > 0) {
                partStr += (hundred === 1 ? "" : digitToKorean[hundred]) + "ë°±";
            }
            
            // ì‹­ì˜ ìë¦¬
            const ten = Math.floor((part % 100) / 10);
            if (ten > 0) {
                partStr += (ten === 1 ? "" : digitToKorean[ten]) + "ì‹­";
            }
            
            // ì¼ì˜ ìë¦¬ - ìˆ˜ì •ëœ ë¶€ë¶„
            const one = part % 10;
            if (one > 0) {
                partStr += digitToKorean[one];
            }
            
            result = partStr + units[unitIndex] + result;
        }
        
        num = Math.floor(num / 10000);
        unitIndex++;
    }
    
    return (isNegative ? "-" : "") + result;
}


// ì…ë ¥ ë°ì´í„°ì— í•œê¸€ ìˆ«ìê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
function hasKoreanNumbers() {
    const koreanNumberPattern = /[ì¼ì´ì‚¼ì‚¬ì˜¤ìœ¡ì¹ íŒ”êµ¬ì‹­ë°±ì²œë§Œì–µì¡°]/;
    
    // ëª¨ë“  ì°¨íŠ¸ íƒ€ì…ì—ì„œ í•œê¸€ ìˆ«ì í™•ì¸
    if (chartConfig.type === 'line') {
        const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
        for (let i = 0; i < numberOfLines; i++) {
            const dataInput = document.getElementById(`lineData${i}`);
            if (dataInput && koreanNumberPattern.test(dataInput.value)) {
                return true;
            }
        }
    } else if (chartConfig.type === 'bar') {
        const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
        for (let i = 0; i < numberOfBars; i++) {
            const dataInput = document.getElementById(`barData${i}`);
            if (dataInput && koreanNumberPattern.test(dataInput.value)) {
                return true;
            }
        }
    } else if (chartConfig.type === 'pie') {
        const numberOfPies = parseInt(document.getElementById('numberOfPies')?.value) || 1;
        for (let i = 0; i < numberOfPies; i++) {
            const dataInput = document.getElementById(`pieData${i}`);
            if (dataInput && koreanNumberPattern.test(dataInput.value)) {
                return true;
            }
        }
    }
    
    return false;
}
        
        // ë ˆì´ë¸” íŒŒì‹± (ë‹¤ì–‘í•œ êµ¬ë¶„ì ì§€ì›)
        function parseLabels(labelString) {
            if (!labelString || labelString.trim() === '') return [];
            
            const separators = /[,|;\t]+/;
            return labelString.split(separators)
                .map(l => l.trim())
                .filter(l => l);
        }
        
        // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        function getHighlightSettings() {
            const highlights = [];
            const highlightItems = document.querySelectorAll('#highlightList .highlight-item');
            
            highlightItems.forEach(item => {
                const selects = item.querySelectorAll('select');
                const indexInput = item.querySelector('input[type="number"]');
                
                if (indexInput && indexInput.value) {
                    const highlight = {
                        index: parseInt(indexInput.value),
                        series: 1 // ê¸°ë³¸ê°’
                    };
                    
                    // ì‹œë¦¬ì¦ˆ ì„ íƒ ë“œë¡­ë‹¤ìš´ì´ ìˆëŠ”ì§€ í™•ì¸ (2ê°œ ì´ìƒì˜ selectê°€ ìˆìœ¼ë©´ ì²« ë²ˆì§¸ëŠ” ì‹œë¦¬ì¦ˆ ì„ íƒ)
                    if (selects.length >= 2) {
                        highlight.series = parseInt(selects[0].value);
                        highlight.color = selects[1].value; // ë‘ ë²ˆì§¸ selectëŠ” ìƒ‰ìƒ
                    } else if (selects.length === 1) {
                        highlight.color = selects[0].value; // í•˜ë‚˜ë¿ì´ë©´ ìƒ‰ìƒ
                    }
                    
                    highlights.push(highlight);
                }
            });
            
            return highlights;
        }
        
        // ìŠ¤ë§ˆíŠ¸ ê²©ìì„  ê°„ê²© ê³„ì‚° í•¨ìˆ˜
function calculateSmartGridInterval(min, max, range) {
    // ì ì ˆí•œ ê²©ìì„  ê°œìˆ˜ (5-8ê°œ ì •ë„)
    const targetGridLines = 6;
    let rawInterval = range / targetGridLines;
    
    // ê¹”ë”í•œ ìˆ˜ë¡œ ë°˜ì˜¬ë¦¼
    const magnitude = Math.pow(10, Math.floor(Math.log10(rawInterval)));
    const normalizedInterval = rawInterval / magnitude;
    
    let niceInterval;
    if (normalizedInterval <= 1) {
        niceInterval = 1;
    } else if (normalizedInterval <= 2) {
        niceInterval = 2;
    } else if (normalizedInterval <= 5) {
        niceInterval = 5;
    } else {
        niceInterval = 10;
    }
    
    return niceInterval * magnitude;
}
        // ì°¨íŠ¸ ìƒì„± (ë©”ì¸ í•¨ìˆ˜)
        function generateChart() {
            console.log('ğŸ¨ ì°¨íŠ¸ ìƒì„± ì¤‘...');
            
            try {
                const canvas = document.getElementById('previewCanvas');
                if (!canvas) {
                    console.error('ìº”ë²„ìŠ¤ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                
                // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • (ë¯¸ë¦¬ë³´ê¸°ìš©)
                canvas.width = canvas.clientWidth;
                canvas.height = 600;
                
                // ë°°ê²½ ì„¤ì •
                const showBackground = document.getElementById('showBackground')?.checked !== false;
                
                if (showBackground) {
                    ctx.fillStyle = chartConfig.backgroundColor === 'dark' ? '#1E3A8A' : '#F8FAFC';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    // íˆ¬ëª… ë°°ê²½
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                
                // ì°¨íŠ¸ ì˜ì—­ ê³„ì‚° (ë¯¸ë¦¬ë³´ê¸°ìš©)
                const padding = 60;
                const chartX = padding;
                const chartY = padding;
                const chartWidth = canvas.width - padding * 2;
                const chartHeight = canvas.height - padding * 2;
                
                // ì°¨íŠ¸ íƒ€ì…ë³„ ê·¸ë¦¬ê¸°
                switch (chartConfig.type) {
                    case 'line':
                        drawMultiLineChart(ctx, chartX, chartY, chartWidth, chartHeight);
                        break;
                    case 'bar':
                        drawMultiBarChart(ctx, chartX, chartY, chartWidth, chartHeight);
                        break;
                    case 'pie':
                        drawMultiPieChart(ctx, chartX, chartY, chartWidth, chartHeight);
                        break;
                    case 'table':
                        drawTable(ctx, chartX, chartY, chartWidth, chartHeight);
                        break;
                }
                
                // ì°¨íŠ¸ ì •ë³´ ì €ì¥
                currentChart = {
                    type: chartConfig.type,
                    config: chartConfig,
                    area: { x: 214, y: 312, width: 1398, height: 666 },
                    graphArea: { x: 274, y: 372, width: 1278, height: 546 }
                };
                
                // URL ì—…ë°ì´íŠ¸
                updateChartURL();
                
                console.log('âœ… ì°¨íŠ¸ ìƒì„± ì™„ë£Œ');
                
            } catch (error) {
                console.error('âš  ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜:', error);
                showStatus('ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
            }
        }
        
// ë©€í‹° ì„ í˜• ì°¨íŠ¸ ê·¸ë¦¬ê¸°
function drawMultiLineChart(ctx, x, y, width, height) {
    const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
    const useSameStyle = document.getElementById('useSameStyle')?.checked && numberOfLines > 1;
    const textColor = chartConfig.backgroundColor === 'dark' ? '#FFFFFF' : '#374151';
    const gridColor = chartConfig.backgroundColor === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
    const showGridlines = document.getElementById('showGridlines')?.checked !== false;
    const showAxisLabels = document.getElementById('showAxisLabels')?.checked !== false;
    const curvedLines = document.getElementById('curvedLines')?.checked !== false;
    const fillUnderLine = document.getElementById('fillUnderLine')?.checked !== false;
    const customGridlines = true;
    const gridlineInterval = parseFloat(document.getElementById('gridlineInterval')?.value) || 10;
    const yAxisMin = parseFloat(document.getElementById('yAxisMin')?.value) || 0;
    
    // ì°¨íŠ¸ í­ ì¡°ì ˆ
    const chartWidthPercent = parseInt(document.getElementById('chartWidthLine')?.value) || 100;
    const adjustedWidth = width * (chartWidthPercent / 100);
    const widthOffset = (width - adjustedWidth) / 2;
    
    // ëª¨ë“  ì‹œë¦¬ì¦ˆ ë°ì´í„° ìˆ˜ì§‘
    const allSeries = [];
    let allData = [];
    let labels = [];
    
    for (let i = 0; i < numberOfLines; i++) {
        const dataInput = document.getElementById(`lineData${i}`);
        const labelsInput = document.getElementById(`lineLabels${i}`);
        
        if (dataInput) {
            const data = parsePieData(dataInput.value);
            if (data.length > 0) {
                const series = {
                    data: data,
                    color: document.getElementById(`lineColor${i}`)?.value || colorPalette[i % colorPalette.length],
                    pointColor: document.getElementById(`pointColor${i}`)?.value || colorPalette[i % colorPalette.length]
                };
                
                // ìŠ¤íƒ€ì¼ ì„¤ì •
                series.lineWidth = parseInt(document.getElementById(`lineWidthGlobal`)?.value) || 2;
                series.pointSize = parseInt(document.getElementById(`pointSizeGlobal`)?.value) || 6;
                series.pointStrokeWidth = parseInt(document.getElementById(`pointStrokeWidthGlobal`)?.value) || 2;
                series.pointStrokeColor = series.color;
                series.showPoints = document.getElementById(`showPointsGlobal`)?.checked !== false;
                series.showPointStroke = document.getElementById(`showPointStrokeGlobal`)?.checked !== false;
                series.showPointValues = document.getElementById(`showPointValuesGlobal`)?.checked !== false;
                
                allSeries.push(series);
                allData = allData.concat(data);
                
                if (i === 0 && labelsInput) {
                    labels = parseLabels(labelsInput.value);
                }
            }
        }
    }
    
    if (allSeries.length === 0) return;
    
    const dataMax = Math.max(...allData);
    const dataMin = Math.min(...allData);
    const max = Math.max(dataMax, 0);
    const min = Math.min(yAxisMin, dataMin);
    const range = max - min || 1;
    
    // ê²©ìì„ ê³¼ ì¶• ê·¸ë¦¬ê¸° - ë™ì¼í•œ min, max, range ì‚¬ìš©
    drawGridAndAxes(ctx, x + widthOffset, y, adjustedWidth, height, min, max, range, textColor, gridColor, showGridlines, showAxisLabels, customGridlines, gridlineInterval);
    
            
            // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
            const highlights = document.getElementById('enableHighlight')?.checked ? getHighlightSettings() : [];
            
            // ê° ì‹œë¦¬ì¦ˆ ê·¸ë¦¬ê¸°
            allSeries.forEach((series, seriesIndex) => {
                const leftMargin = 40; // ì™¼ìª½ ì—¬ë°± 40px
                const rightMargin = 40; // ì˜¤ë¥¸ìª½ ì—¬ë°± 40px
                const availableWidth = adjustedWidth - leftMargin - rightMargin;
                
                const points = series.data.map((value, index) => ({
                    x: x + widthOffset + leftMargin + (index * availableWidth / Math.max(series.data.length - 1, 1)),
                    y: y + height - ((value - min) * height / range) * 0.9
                }));
                
                // ì„  ì•„ë˜ ì±„ìš°ê¸° (ì˜µì…˜)
                if (fillUnderLine) {
                    // ì„  ìƒ‰ìƒì„ ê¸°ë°˜ìœ¼ë¡œ íˆ¬ëª…í•œ ì±„ìš°ê¸° ìƒ‰ìƒ ìƒì„±
                    const fillColor = hexToRgba(series.color, 0.25);
                    ctx.fillStyle = fillColor;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, y + height);
                    
                    if (curvedLines && points.length > 2) {
                        // ê³¡ì„  ì±„ìš°ê¸° - ì²« í¬ì¸íŠ¸ë¡œ ì´ë™ í›„ ê³¡ì„  ê·¸ë¦¬ê¸°
                        ctx.lineTo(points[0].x, points[0].y);
                        for (let i = 0; i < points.length - 1; i++) {
                            const p0 = points[Math.max(i - 1, 0)];
                            const p1 = points[i];
                            const p2 = points[i + 1];
                            const p3 = points[Math.min(i + 2, points.length - 1)];
                            
                            const cp1x = p1.x + (p2.x - p0.x) * 0.5 / 6;
                            const cp1y = p1.y + (p2.y - p0.y) * 0.5 / 6;
                            const cp2x = p2.x - (p3.x - p1.x) * 0.5 / 6;
                            const cp2y = p2.y - (p3.y - p1.y) * 0.5 / 6;
                            
                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                        }
                    } else {
                        // ì§ì„  ì±„ìš°ê¸°
                        points.forEach(point => {
                            ctx.lineTo(point.x, point.y);
                        });
                    }
                    
                    ctx.lineTo(points[points.length - 1].x, y + height);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // ì„  ê·¸ë¦¬ê¸°
                ctx.strokeStyle = series.color;
                ctx.lineWidth = series.lineWidth;
                ctx.beginPath();
                
                if (curvedLines && points.length > 2) {
                    drawCardinalSpline(ctx, points, 0.5);
                } else {
                    points.forEach((point, index) => {
                        if (index === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                }
                ctx.stroke();
                
                // í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
                if (series.showPoints) {
                    points.forEach((point, index) => {
                        ctx.beginPath();
                        
                        // ê°•ì¡° í¬ì¸íŠ¸ í™•ì¸ (ì‹œë¦¬ì¦ˆë³„)
                        const isHighlighted = highlights.some(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const highlight = highlights.find(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const currentPointSize = isHighlighted ? series.pointSize * 1.5 : series.pointSize;
                        const currentPointColor = isHighlighted ? highlight.color : series.pointColor;
                        
                        ctx.arc(point.x, point.y, currentPointSize, 0, Math.PI * 2);
                        ctx.fillStyle = currentPointColor;
                        ctx.fill();
                        
                        if (series.showPointStroke && series.pointStrokeWidth > 0) {
                            ctx.strokeStyle = series.pointStrokeColor;
                            ctx.lineWidth = series.pointStrokeWidth;
                            ctx.stroke();
                        }
                    });
                }
                
                // í¬ì¸íŠ¸ ê°’ í‘œì‹œ
if (series.showPointValues) {
    const fontSize = parseInt(document.getElementById('lineValueFontSizeGlobal')?.value) || 55;
    ctx.font = `bold ${fontSize}px Noto Sans KR`;
                    ctx.textAlign = 'center';
                    points.forEach((point, index) => {
                        const isHighlighted = highlights.some(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const highlight = highlights.find(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const currentTextColor = isHighlighted ? highlight.color : series.color; // ì„  ìƒ‰ìƒ ì‚¬ìš©
                        const currentPointSize = isHighlighted ? series.pointSize * 1.5 : series.pointSize;
                        
                        ctx.fillStyle = currentTextColor;
                        ctx.fillText(getDisplayValue('line', seriesIndex, index, series.data[index]), point.x, point.y - currentPointSize - 8);
                    });
                }
            });
            
            // ë ˆì´ë¸” ê·¸ë¦¬ê¸° (ì²« ë²ˆì§¸ ì‹œë¦¬ì¦ˆ ê¸°ì¤€)
            if (allSeries.length > 0 && labels.length > 0) {
                const firstSeries = allSeries[0];
                const leftMargin = 40;
                const rightMargin = 40;
                const availableWidth = adjustedWidth - leftMargin - rightMargin;
                
                const points = firstSeries.data.map((value, index) => ({
                    x: x + widthOffset + leftMargin + (index * availableWidth / Math.max(firstSeries.data.length - 1, 1)),
                    y: y + height - ((value - min) * height / range) * 0.9
                }));
                
                ctx.fillStyle = textColor;
                ctx.font = '30px Noto Sans KR';
                ctx.textAlign = 'center';
                points.forEach((point, index) => {
                    const label = labels[index] || `${index + 1}`;
                    ctx.fillText(label, point.x, y + height + 20);
                });
            }
        }
        
        // ë©€í‹° ë§‰ëŒ€ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
        function drawMultiBarChart(ctx, x, y, width, height) {
            const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
            const textColor = chartConfig.backgroundColor === 'dark' ? '#FFFFFF' : '#374151';
            const gridColor = chartConfig.backgroundColor === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            const showGridlines = document.getElementById('showGridlines')?.checked !== false;
            const showAxisLabels = document.getElementById('showAxisLabels')?.checked !== false;
            const horizontalBars = document.getElementById('horizontalBars')?.checked !== false;
            const stackedBars = document.getElementById('stackedBars')?.checked !== false;
            const showBarValues = document.getElementById('showBarValues')?.checked !== false;
            const customGridlines = true;
            const gridlineInterval = parseFloat(document.getElementById('gridlineInterval')?.value) || 5;
            const barWidthPx = parseInt(document.getElementById('barWidth')?.value) || 110;
            const yAxisMin = parseFloat(document.getElementById('yAxisMinBar')?.value) || 0;
            
            // ì°¨íŠ¸ í­ ì¡°ì ˆ
            const chartWidthPercent = parseInt(document.getElementById('chartWidthBar')?.value) || 100;
            const adjustedWidth = width * (chartWidthPercent / 100);
            const widthOffset = (width - adjustedWidth) / 2;
            
            // ëª¨ë“  ì‹œë¦¬ì¦ˆ ë°ì´í„° ìˆ˜ì§‘
            const allSeries = [];
            let allData = [];
            let labels = [];
            let maxDataLength = 0;
            
            for (let i = 0; i < numberOfBars; i++) {
                const dataInput = document.getElementById(`barData${i}`);
                const labelsInput = document.getElementById(`barLabels${i}`);
                const useIndividualColors = document.getElementById(`useIndividualBarColors${i}`)?.checked || false;
                
                if (dataInput) {
                    const data = parsePieData(dataInput.value);
                    if (data.length > 0) {
                        const series = {
                            data: data,
                            color: document.getElementById(`barColor${i}`)?.value || colorPalette[i % colorPalette.length],
                            useIndividualColors: useIndividualColors,
                            individualColors: []
                        };
                        
                        // ê°œë³„ ìƒ‰ìƒ ì„¤ì •ì´ í™œì„±í™”ëœ ê²½ìš° ê° ë§‰ëŒ€ë³„ ìƒ‰ìƒ ìˆ˜ì§‘
                        if (useIndividualColors) {
                            for (let j = 0; j < data.length; j++) {
                                const colorInput = document.getElementById(`individualBarColor${i}_${j}`);
                                series.individualColors.push(colorInput ? colorInput.value : colorPalette[j % colorPalette.length]);
                            }
                        }
                        
                        allSeries.push(series);
                        allData = allData.concat(data);
                        maxDataLength = Math.max(maxDataLength, data.length);
                        
                        if (i === 0 && labelsInput) {
                            labels = parseLabels(labelsInput.value);
                        }
                    }
                }
            }
            
            if (allSeries.length === 0) return;
            
            let max, min, range;
            
            if (stackedBars) {
                const stackedTotals = [];
                for (let i = 0; i < maxDataLength; i++) {
                    let total = 0;
                    allSeries.forEach(series => {
                        if (i < series.data.length) {
                            total += series.data[i];
                        }
                    });
                    stackedTotals.push(total);
                }
                max = Math.max(...stackedTotals, 0); // ìµœëŒ€ê°’ì´ 0ë³´ë‹¤ ì‘ìœ¼ë©´ 0ì„ ìµœëŒ€ê°’ìœ¼ë¡œ
                min = Math.min(yAxisMin, 0);
            } else {
                const dataMax = Math.max(...allData);
                const dataMin = Math.min(...allData);
                max = Math.max(dataMax, 0); // ìµœëŒ€ê°’ì´ 0ë³´ë‹¤ ì‘ìœ¼ë©´ 0ì„ ìµœëŒ€ê°’ìœ¼ë¡œ
                min = Math.min(yAxisMin, dataMin); // ì‹¤ì œ ë°ì´í„° ìµœì†Ÿê°’ê³¼ ì‚¬ìš©ì ì„¤ì • ìµœì†Ÿê°’ ì¤‘ ë” ì‘ì€ ê°’
            }
            range = max - min || 1;
            
            // ê²©ìì„ ê³¼ ì¶• ê·¸ë¦¬ê¸° (ì¡°ì ˆëœ í­ ì ìš©)
            drawGridAndAxes(ctx, x + widthOffset, y, adjustedWidth, height, min, max, range, textColor, gridColor, showGridlines, showAxisLabels, customGridlines, gridlineInterval, horizontalBars);
            
            // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
            const highlights = document.getElementById('enableHighlight')?.checked ? getHighlightSettings() : [];
            
            if (stackedBars) {
                // ëˆ„ì  ë§‰ëŒ€ ê·¸ë¦¬ê¸°
                const barSpacing = horizontalBars ? height / maxDataLength : adjustedWidth / maxDataLength;
                const actualBarWidth = Math.min(barWidthPx, barSpacing * 0.8);
                
                for (let dataIndex = 0; dataIndex < maxDataLength; dataIndex++) {
                    let cumulativeValue = 0;
                    
                    allSeries.forEach((series, seriesIndex) => {
                        if (dataIndex < series.data.length) {
                            const value = series.data[dataIndex];
                            
                            // ê°•ì¡° í™•ì¸ (ì‹œë¦¬ì¦ˆë³„)
                            const isHighlighted = highlights.some(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                            const highlight = highlights.find(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                            
                            // ìƒ‰ìƒ ê²°ì • (ê°œë³„ ìƒ‰ìƒ > ê°•ì¡° ìƒ‰ìƒ > ì‹œë¦¬ì¦ˆ ìƒ‰ìƒ ìˆœ)
                            let currentColor;
                            if (series.useIndividualColors && series.individualColors[dataIndex]) {
                                currentColor = series.individualColors[dataIndex];
                            } else if (isHighlighted) {
                                currentColor = highlight.color;
                            } else {
                                currentColor = series.color;
                            }
                            
                            if (horizontalBars) {
                                const zeroX = x + widthOffset + ((-min) / range) * adjustedWidth * 0.9;
                                const barWidth = Math.abs((value / range) * adjustedWidth * 0.9);
                                const barY = y + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
                                let barX;
                                
                                if (value >= 0) {
                                    barX = zeroX + ((cumulativeValue >= 0 ? cumulativeValue : 0) / range) * adjustedWidth * 0.9;
                                } else {
                                    barX = zeroX - barWidth + ((cumulativeValue < 0 ? cumulativeValue : 0) / range) * adjustedWidth * 0.9;
                                }
                                
                                const useArrow = document.getElementById('arrowBars')?.checked || false;
if(useArrow){ drawArrow(ctx, barX, barY, barWidth, actualBarWidth, currentColor, true, (value<0)); } else { ctx.fillStyle=currentColor; ctx.fillRect(barX, barY, barWidth, actualBarWidth); }
                                
                                if (showBarValues) {
    ctx.fillStyle = currentColor;
    const fontSize = parseInt(document.getElementById('barValueFontSize')?.value) || 55;
    ctx.font = `bold ${fontSize}px Noto Sans KR`;
    ctx.textAlign = 'left';  // 'center'ì—ì„œ 'left'ë¡œ ë³€ê²½
    const textX = barX + barWidth + 8;  // ë§‰ëŒ€ ëì—ì„œ 8px ë–¨ì–´ì§„ ê³³
    ctx.fillText(getDisplayValue('bar', seriesIndex, dataIndex, value), textX, barY + actualBarWidth/2 + 5);
}
                            } else {
                                const zeroY = y + height - ((-min) / range) * height * 0.9;
                                const barHeight = Math.abs((value / range) * height * 0.9);
                                const barX = x + widthOffset + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
                                let barY;
                                
                                if (value >= 0) {
                                    barY = zeroY - barHeight - ((cumulativeValue >= 0 ? cumulativeValue : 0) / range) * height * 0.9;
                                } else {
                                    barY = zeroY + ((cumulativeValue < 0 ? Math.abs(cumulativeValue) : 0) / range) * height * 0.9;
                                }
                                
                                const useArrow = document.getElementById('arrowBars')?.checked || false;
if(useArrow){ drawArrow(ctx, barX, barY, actualBarWidth, barHeight, currentColor, false, (value<0)); } else { ctx.fillStyle=currentColor; ctx.fillRect(barX, barY, actualBarWidth, barHeight); }
                                
                                if (showBarValues) {
                                    ctx.fillStyle = currentColor;
                                    const fontSize = parseInt(document.getElementById('barValueFontSize')?.value) || 55;
ctx.font = `bold ${fontSize}px Noto Sans KR`;
                                    ctx.textAlign = 'center';
                                    const textY = value >= 0 ? barY - 8 : barY + barHeight + fontSize + 5;
                                    ctx.fillText(getDisplayValue('bar', seriesIndex, dataIndex, value), barX + actualBarWidth/2, textY);
                                }
                            }
                            
                            cumulativeValue += value;
                        }
                    });
                }
            } else {
                // ì¼ë°˜ ë§‰ëŒ€ ê·¸ë¦¬ê¸°
                const barSpacing = horizontalBars ? height / maxDataLength : adjustedWidth / maxDataLength;
                const actualBarWidth = Math.min(barWidthPx, barSpacing * 0.8);
                const seriesSpacing = parseInt(document.getElementById('barSpacing')?.value) || 5;
                const seriesBarWidth = numberOfBars > 1 ? (actualBarWidth - (seriesSpacing * (numberOfBars - 1))) / numberOfBars : actualBarWidth;
                
                allSeries.forEach((series, seriesIndex) => {
                    series.data.forEach((value, dataIndex) => {
                        // ê°•ì¡° í™•ì¸
                        const isHighlighted = highlights.some(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                        const highlight = highlights.find(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                        
                        // ìƒ‰ìƒ ê²°ì • (ê°œë³„ ìƒ‰ìƒ > ê°•ì¡° ìƒ‰ìƒ > ì‹œë¦¬ì¦ˆ ìƒ‰ìƒ ìˆœ)
                        let currentColor;
                        if (series.useIndividualColors && series.individualColors[dataIndex]) {
                            currentColor = series.individualColors[dataIndex];
                        } else if (isHighlighted) {
                            currentColor = highlight.color;
                        } else {
                            currentColor = series.color;
                        }
                        
                        if (horizontalBars) {
                            const zeroX = x + widthOffset + ((-min) / range) * adjustedWidth * 0.9; // 0ì˜ X ìœ„ì¹˜
                            const barWidth = Math.abs((value / range) * adjustedWidth * 0.9);
                            const baseY = y + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
                            const barY = baseY + (seriesIndex * (seriesBarWidth + seriesSpacing));
                            const barX = value >= 0 ? zeroX : zeroX - barWidth;
                            
                            const useArrow = document.getElementById('arrowBars')?.checked || false;
if(useArrow){ drawArrow(ctx, barX, barY, barWidth, seriesBarWidth, currentColor, true, (value<0)); } else { ctx.fillStyle=currentColor; ctx.fillRect(barX, barY, barWidth, seriesBarWidth); }
                            
                            if (showBarValues) {
    ctx.fillStyle = currentColor;
    const fontSize = parseInt(document.getElementById('barValueFontSize')?.value) || 55;
    ctx.font = `bold ${fontSize}px Noto Sans KR`;
    ctx.textAlign = 'left';  // 'center'ì—ì„œ 'left'ë¡œ ë³€ê²½
    const textX = barX + barWidth + 8;  // ë§‰ëŒ€ ëì—ì„œ 8px ë–¨ì–´ì§„ ê³³
    ctx.fillText(getDisplayValue('bar', seriesIndex, dataIndex, value), textX, barY + seriesBarWidth/2 + 5);
}
                        } else {
                            const zeroY = y + height - ((-min) / range) * height * 0.9; // 0ì˜ Y ìœ„ì¹˜
                            const barHeight = Math.abs((value / range) * height * 0.9);
                            const baseX = x + widthOffset + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
                            const barX = baseX + (seriesIndex * (seriesBarWidth + seriesSpacing));
                            const barY = value >= 0 ? zeroY - barHeight : zeroY;
                            
                            const useArrow = document.getElementById('arrowBars')?.checked || false;
if(useArrow){ drawArrow(ctx, barX, barY, seriesBarWidth, barHeight, currentColor, false, (value<0)); } else { ctx.fillStyle=currentColor; ctx.fillRect(barX, barY, seriesBarWidth, barHeight); }
                            
                            if (showBarValues) {
                                ctx.fillStyle = currentColor;
                                const fontSize = parseInt(document.getElementById('barValueFontSize')?.value) || 55;
ctx.font = `bold ${fontSize}px Noto Sans KR`;
                                ctx.textAlign = 'center';
                                const textY = value >= 0 ? barY - 8 : barY + barHeight + fontSize + 5;
                                ctx.fillText(getDisplayValue('bar', seriesIndex, dataIndex, value), barX + seriesBarWidth/2, textY);
                            }
                        }
                    });
                });
            }
            
            // ë ˆì´ë¸” ê·¸ë¦¬ê¸°
            if (labels.length > 0) {
                ctx.fillStyle = textColor;
                ctx.font = '30px Noto Sans KR';
                
                for (let i = 0; i < Math.min(labels.length, maxDataLength); i++) {
                    const label = labels[i];
                    
                    if (horizontalBars) {
                        const barSpacing = height / maxDataLength;
                        const barY = y + (i * barSpacing) + barSpacing / 2;
                        ctx.textAlign = 'center';
                        ctx.fillText(label, x + widthOffset - 10, barY + 5);
                    } else {
                        const barSpacing = adjustedWidth / maxDataLength;
                        const barX = x + widthOffset + (i * barSpacing) + barSpacing / 2;
                        ctx.textAlign = 'center';
                        ctx.fillText(label, barX, y + height + 20);
                    }
                }
            }
        }
        
        // ë©€í‹° íŒŒì´ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
        function drawMultiPieChart(ctx, x, y, width, height) {
            const numberOfPies = parseInt(document.getElementById('numberOfPies')?.value) || 1;
            const textColor = chartConfig.backgroundColor === 'dark' ? '#FFFFFF' : '#374151';
            const showPieLabels = document.getElementById('showPieLabels')?.checked !== false;
            const showPieValues = document.getElementById('showPieValues')?.checked !== false;
            
            const pieWidth = width / numberOfPies;
            const pieRadius = Math.min(pieWidth, height) / 2 - 100;
            
            // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
            const highlights = document.getElementById('enableHighlight')?.checked ? getHighlightSettings() : [];
            
            for (let pieIndex = 0; pieIndex < numberOfPies; pieIndex++) {
                const dataInput = document.getElementById(`pieData${pieIndex}`);
                const labelsInput = document.getElementById(`pieLabels${pieIndex}`);
                const isDonutInput = document.getElementById(`isDonut${pieIndex}`);
                const isHalfPieInput = document.getElementById(`isHalfPie${pieIndex}`);
                
                if (!dataInput) continue;
                
                const data = parsePieData(dataInput.value); // parsePieData ì‚¬ìš©
                const labels = parseLabels(labelsInput ? labelsInput.value : '');
                
                if (data.length === 0) continue;
                
                const centerX = x + (pieIndex * pieWidth) + pieWidth / 2;
                const centerY = y + height / 2;
                const isDonut = isDonutInput ? isDonutInput.checked : false;
                const isHalfPie = isHalfPieInput ? isHalfPieInput.checked : false;
                const donutThickness = parseInt(document.getElementById(`donutThickness${pieIndex}`)?.value) || 40;
                const innerRadius = isDonut ? pieRadius * ((100 - donutThickness) / 100) : 0;
                
                const total = data.reduce((sum, value) => sum + value, 0);
                let currentAngle = isHalfPie ? -Math.PI : -Math.PI / 2; // Half PieëŠ” -Ï€ë¶€í„° ì‹œì‘
                const totalAngle = isHalfPie ? Math.PI : Math.PI * 2; // Half PieëŠ” Ï€(180ë„)ë§Œ ì‚¬ìš©
                
                // íŒŒì´ ì¡°ê° ê·¸ë¦¬ê¸°
                data.forEach((value, index) => {
                    const sliceAngle = (value / total) * totalAngle; // Half Pieì˜ ê²½ìš° Ï€ë§Œ ì‚¬ìš©
                    
                    const colorInput = document.getElementById(`pieColor${pieIndex}_${index}`);
                    let color = colorInput ? colorInput.value : colorPalette[index % colorPalette.length];
                    
                    // ê°•ì¡° ê¸°ëŠ¥ í™•ì¸ (ìƒ‰ìƒë§Œ ë³€ê²½, í¬ê¸°/ìœ„ì¹˜ëŠ” ê·¸ëŒ€ë¡œ)
                    const isHighlighted = highlights.some(h => h.index === index + 1 && h.series === pieIndex + 1);
                    if (isHighlighted) {
                        const highlight = highlights.find(h => h.index === index + 1 && h.series === pieIndex + 1);
                        color = highlight.color;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, pieRadius, currentAngle, currentAngle + sliceAngle);
                    
                    if (isDonut) {
                        ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
                    } else {
                        ctx.lineTo(centerX, centerY);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // ë ˆì´ë¸” í‘œì‹œ (í¼ì„¼íŠ¸ ì œì™¸)
if (showPieLabels) {
    const labelAngle = currentAngle + sliceAngle / 2;
    const labelRadius = pieRadius + (isHalfPie ? 30 : 50);
    const labelX = centerX + Math.cos(labelAngle) * labelRadius;
    const labelY = centerY + Math.sin(labelAngle) * labelRadius;
    
    ctx.fillStyle = textColor;
    const fontSize = parseInt(document.getElementById('pieValueFontSize')?.value) || 60;
    ctx.font = isHighlighted ? `bold ${fontSize}px Noto Sans KR` : `${fontSize}px Noto Sans KR`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    const label = labels[index] || `ì¡°ê° ${index + 1}`;
    ctx.fillText(`${label}`, labelX, labelY);
}
                    
                    // ê°’ë„ í‘œì‹œ
if (showPieValues) {
    const valueRadius = pieRadius + (isHalfPie ? 15 : 30); // PSDì™€ ë™ì¼í•œ ìœ„ì¹˜
    const valueX = centerX + Math.cos(currentAngle + sliceAngle / 2) * valueRadius;
    const valueY = centerY + Math.sin(currentAngle + sliceAngle / 2) * valueRadius;
    
    const baseFontSize = parseInt(document.getElementById('pieValueFontSize')?.value) || 60;
    const fontSize = isHighlighted ? baseFontSize + 10 : baseFontSize;
    
    ctx.fillStyle = color;
    ctx.font = `bold ${fontSize}px Noto Sans KR`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // PSDì™€ ë™ì¼í•˜ê²Œ í…Œë‘ë¦¬ ì—†ì´ í‘œì‹œ
    ctx.fillText(getDisplayValue('pie', pieIndex, index, value), valueX, valueY);
}
                    
                    currentAngle += sliceAngle;
                });
            }
        }

        // í…Œì´ë¸” ê·¸ë¦¬ê¸°
function drawTable(ctx, x, y, width, height) {
    const tableWidthPercent = parseInt(document.getElementById('tableWidth')?.value) || 100;
    const tableHeightPercent = parseInt(document.getElementById('tableHeight')?.value) || 100;
    
    const adjustedWidth = width * (tableWidthPercent / 100);
    const adjustedHeight = height * (tableHeightPercent / 100);
    const widthOffset = (width - adjustedWidth) / 2;
    const heightOffset = (height - adjustedHeight) / 2;
    
    const finalX = x + widthOffset;
    const finalY = y + heightOffset;
    
    const cellWidth = adjustedWidth / (tableCols + (document.getElementById('showRowNumbers')?.checked ? 1 : 0));
    const cellHeight = adjustedHeight / tableRows;
    
    const borderColor = document.getElementById('borderColor')?.value || '#E5E7EB';
    const borderWidth = parseInt(document.getElementById('borderWidth')?.value) || 3;
    const borderStyle = document.getElementById('borderStyle')?.value || 'solid';
    const textAlign = document.getElementById('textAlign')?.value || 'center';
    const cellPadding = parseInt(document.getElementById('cellPadding')?.value) || 8;
    
    const headerBgColor = document.getElementById('headerBgColor')?.value || '#3B82F6';
    const headerTextColor = document.getElementById('headerTextColor')?.value || '#FFFFFF';
    
    const stripedRows = document.getElementById('stripedRows')?.checked !== false;
    let oddRowBgColor, oddRowTextColor, evenRowBgColor, evenRowTextColor;
    
    if (stripedRows) {
        oddRowBgColor = document.getElementById('oddRowBgColor')?.value || '#F9FAFB';
        oddRowTextColor = document.getElementById('oddRowTextColor')?.value || '#374151';
        evenRowBgColor = document.getElementById('evenRowBgColor')?.value || '#FFFFFF';
        evenRowTextColor = document.getElementById('evenRowTextColor')?.value || '#374151';
    } else {
        oddRowBgColor = evenRowBgColor = document.getElementById('uniformRowBgColor')?.value || '#FFFFFF';
        oddRowTextColor = evenRowTextColor = document.getElementById('uniformRowTextColor')?.value || '#374151';
    }
    
    const showRowNumbers = document.getElementById('showRowNumbers')?.checked !== false;
    const startCol = showRowNumbers ? 1 : 0;
    
    // í…Œì´ë¸” ê·¸ë¦¬ê¸°
    for (let i = 0; i < tableRows; i++) {
        for (let j = 0; j < tableCols + (showRowNumbers ? 1 : 0); j++) {
            const cellX = finalX + (j * cellWidth);
            const cellY = finalY + (i * cellHeight);
            
            // ë°°ê²½ìƒ‰ ê²°ì •
            let bgColor, textColor;
            if (i === 0) {
                bgColor = headerBgColor;
                textColor = headerTextColor;
            } else {
                if (stripedRows) {
                    if (i % 2 === 1) {
                        bgColor = oddRowBgColor;
                        textColor = oddRowTextColor;
                    } else {
                        bgColor = evenRowBgColor;
                        textColor = evenRowTextColor;
                    }
                } else {
                    bgColor = oddRowBgColor;
                    textColor = oddRowTextColor;
                }
            }
            
            // ì…€ ë°°ê²½
            ctx.fillStyle = bgColor;
            ctx.fillRect(cellX, cellY, cellWidth, cellHeight);
            
            // í…Œë‘ë¦¬ (ì ì„  ì²˜ë¦¬)
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            if (borderStyle === 'dashed') {
                ctx.setLineDash([5, 5]);
            } else if (borderStyle === 'dotted') {
                ctx.setLineDash([2, 2]);
            } else {
                ctx.setLineDash([]);
            }
            ctx.strokeRect(cellX, cellY, cellWidth, cellHeight);
            
            
            // í…ìŠ¤íŠ¸
            let cellText = '';
            if (showRowNumbers && j === 0) {
                cellText = i === 0 ? '#' : i.toString();
            } else {
                const dataCol = showRowNumbers ? j - 1 : j;
                cellText = tableData[i] && tableData[i][dataCol] ? tableData[i][dataCol] : '';
            }
            
            if (cellText) {
                ctx.fillStyle = textColor;
                const headerFontSize = parseInt(document.getElementById('headerFontSize')?.value) || 30;
const bodyFontSize = parseInt(document.getElementById('bodyFontSize')?.value) || 30;
ctx.font = i === 0 ? `bold ${headerFontSize}px Noto Sans KR` : `${bodyFontSize}px Noto Sans KR`;
                ctx.textBaseline = 'middle';
                
                let textX;
                if (textAlign === 'left') {
                    ctx.textAlign = 'left';
                    textX = cellX + cellPadding;
                } else if (textAlign === 'right') {
                    ctx.textAlign = 'right';
                    textX = cellX + cellWidth - cellPadding;
                } else {
                    ctx.textAlign = 'center';
                    textX = cellX + cellWidth / 2;
                }
                
                ctx.fillText(cellText, textX, cellY + cellHeight / 2);
            }
        }
    }
    
    ctx.setLineDash([]); // ì ì„  ë¦¬ì…‹
}
        
        // ê²©ìì„ ê³¼ ì¶• ê·¸ë¦¬ê¸° (ê³µí†µ í•¨ìˆ˜)
function drawGridAndAxes(ctx, x, y, width, height, min, max, range, textColor, gridColor, showGridlines, showAxisLabels, customGridlines, gridlineInterval, horizontalBars = false) {
    // ë°ì´í„°ê°€ ëª¨ë‘ ì •ìˆ˜ì¸ì§€ í™•ì¸
    const useIntegerFormat = areAllDataValuesInteger(chartConfig.type);
    
    // ê²©ìì„  ê·¸ë¦¬ê¸°
    if (showGridlines) {
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 0.5;
        
        if (customGridlines) {
            // 0ì„ ê¸°ì¤€ìœ¼ë¡œ ìœ„ì•„ë˜ë¡œ ê²©ìì„  ê·¸ë¦¬ê¸°
            const numLinesUp = Math.floor(max / gridlineInterval);
            const numLinesDown = Math.floor(Math.abs(min) / gridlineInterval);
            
            // ì–‘ìˆ˜ ë°©í–¥ ê²©ìì„ 
            for (let i = 0; i <= numLinesUp; i++) {
                const value = parseFloat((i * gridlineInterval).toFixed(10));
                if (value > max) break;
                
                if (horizontalBars) {
                    const gridX = x + ((value - min) * width / range) * 0.9;
                    ctx.lineWidth = value === 0 ? 2 : 0.5;
                    ctx.beginPath();
                    ctx.moveTo(gridX, y);
                    ctx.lineTo(gridX, y + height);
                    ctx.stroke();
                } else {
                    const gridY = y + height - ((value - min) * height / range) * 0.9;
                    ctx.lineWidth = value === 0 ? 2 : 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x, gridY);
                    ctx.lineTo(x + width, gridY);
                    ctx.stroke();
                }
            }
            
            // ìŒìˆ˜ ë°©í–¥ ê²©ìì„ 
            for (let i = 1; i <= numLinesDown; i++) {
                const value = parseFloat((-i * gridlineInterval).toFixed(10));
                if (value < min) break;
                
                if (horizontalBars) {
                    const gridX = x + ((value - min) * width / range) * 0.9;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(gridX, y);
                    ctx.lineTo(gridX, y + height);
                    ctx.stroke();
                } else {
                    const gridY = y + height - ((value - min) * height / range) * 0.9;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x, gridY);
                    ctx.lineTo(x + width, gridY);
                    ctx.stroke();
                }
            }
        } else {
            // ê¸°ë³¸ ëˆˆê¸ˆì„  - ë°ì´í„°ì— ë§ëŠ” ì ì ˆí•œ ê²©ìì„  ìƒì„±
const optimalInterval = calculateSmartGridInterval(min, max, range);
const startValue = Math.ceil(min / optimalInterval) * optimalInterval;

// ê³„ì‚°ëœ ê°„ê²©ìœ¼ë¡œ ê²©ìì„  ê·¸ë¦¬ê¸°
for (let value = startValue; value <= max; value += optimalInterval) {
    if (horizontalBars) {
        const gridX = x + ((value - min) * width / range) * 0.9;
        ctx.lineWidth = Math.abs(value) < 0.001 ? 2 : 0.5;
        ctx.beginPath();
        ctx.moveTo(gridX, y);
        ctx.lineTo(gridX, y + height);
        ctx.stroke();
    } else {
        const gridY = y + height - ((value - min) * height / range) * 0.9;
        ctx.lineWidth = Math.abs(value) < 0.001 ? 2 : 0.5;
        ctx.beginPath();
        ctx.moveTo(x, gridY);
        ctx.lineTo(x + width, gridY);
        ctx.stroke();
    }
}
        }
    }
    
    // ì¶• ê·¸ë¦¬ê¸°
    ctx.strokeStyle = textColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + height);
    ctx.moveTo(x, y + height);
    ctx.lineTo(x + width, y + height);
    ctx.stroke();
    
    // ì¶• ê°’ í‘œì‹œ
    if (showAxisLabels) {
        ctx.fillStyle = textColor;
        ctx.font = '10px Noto Sans KR';
        
        if (customGridlines) {
            const numLinesUp = Math.floor(max / gridlineInterval);
            const numLinesDown = Math.floor(Math.abs(min) / gridlineInterval);
            
            // ì–‘ìˆ˜ ë°©í–¥ ë ˆì´ë¸”
            for (let i = 0; i <= numLinesUp; i++) {
                const value = parseFloat((i * gridlineInterval).toFixed(10));
                if (value > max) break;
                
                const formattedValue = formatAxisValue(value, useIntegerFormat);
                
                if (horizontalBars) {
                    const gridX = x + ((value - min) * width / range) * 0.9;
                    ctx.textAlign = 'center';
                    ctx.fillText(formattedValue, gridX, y + height + 15);
                } else {
                    const gridY = y + height - ((value - min) * height / range) * 0.9;
                    ctx.textAlign = 'right';
                    ctx.fillText(formattedValue, x - 10, gridY + 3);
                }
            }
            
            // ìŒìˆ˜ ë°©í–¥ ë ˆì´ë¸”
            for (let i = 1; i <= numLinesDown; i++) {
                const value = parseFloat((-i * gridlineInterval).toFixed(10));
                if (value < min) break;
                
                const formattedValue = formatAxisValue(value, useIntegerFormat);
                
                if (horizontalBars) {
                    const gridX = x + ((value - min) * width / range) * 0.9;
                    ctx.textAlign = 'center';
                    ctx.fillText(formattedValue, gridX, y + height + 15);
                } else {
                    const gridY = y + height - ((value - min) * height / range) * 0.9;
                    ctx.textAlign = 'right';
                    ctx.fillText(formattedValue, x - 10, gridY + 3);
                }
            }
        } else {
            // ê¸°ë³¸ ì¶• ê°’ í‘œì‹œ - ìŒìˆ˜ê°€ ìˆì„ ê²½ìš° 0ì„ í¬í•¨í•˜ë„ë¡ ìˆ˜ì •
            if (min < 0 && max > 0) {
                // ìŒìˆ˜ì™€ ì–‘ìˆ˜ê°€ ëª¨ë‘ ìˆëŠ” ê²½ìš° - 0ì„ ì¤‘ì‹¬ìœ¼ë¡œ ë ˆì´ë¸” ìƒì„±
                const absMax = Math.max(Math.abs(min), Math.abs(max));
                const step = absMax / 3;
                
                for (let i = -3; i <= 3; i++) {
                    const value = i * step;
                    if (value < min || value > max) continue;
                    
                    const formattedValue = formatAxisValue(value, useIntegerFormat);
                    
                    if (horizontalBars) {
                        const gridX = x + ((value - min) * width / range) * 0.9;
                        ctx.textAlign = 'center';
                        ctx.fillText(formattedValue, gridX, y + height + 15);
                    } else {
                        const gridY = y + height - ((value - min) * height / range) * 0.9;
                        ctx.textAlign = 'right';
                        ctx.fillText(formattedValue, x - 10, gridY + 3);
                    }
                }
            } else {
                // ê¸°ì¡´ ë¡œì§
                for (let i = 0; i <= 5; i++) {
                    if (horizontalBars) {
                        const gridX = x + (i * width / 5);
                        const value = min + (i * range / 5);
                        const formattedValue = formatAxisValue(value, useIntegerFormat);
                        ctx.textAlign = 'center';
                        ctx.fillText(formattedValue, gridX, y + height + 15);
                    } else {
                        const gridY = y + (i * height / 5);
                        const value = max - (i * range / 5);
                        const formattedValue = formatAxisValue(value, useIntegerFormat);
                        ctx.textAlign = 'right';
                        ctx.fillText(formattedValue, x - 10, gridY + 3);
                    }
                }
            }
        }
    }
}
        
        // Cardinal Spline ê³¡ì„  ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawCardinalSpline(ctx, points, tension = 0.5) {
            if (points.length < 2) return;
            
            if (points.length === 2) {
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[1].x, points[1].y);
                return;
            }
            
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[Math.max(i - 1, 0)];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = points[Math.min(i + 2, points.length - 1)];
                
                const cp1x = p1.x + (p2.x - p0.x) * tension / 6;
                const cp1y = p1.y + (p2.y - p0.y) * tension / 6;
                const cp2x = p2.x - (p3.x - p1.x) * tension / 6;
                const cp2y = p2.y - (p3.y - p1.y) * tension / 6;
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }
        }
        
        // ì°¨íŠ¸ URL ì—…ë°ì´íŠ¸
        function updateChartURL() {
            try {
                const params = new URLSearchParams();
                params.set('type', chartConfig.type);
                params.set('bg', chartConfig.backgroundColor);
                
                const baseUrl = window.location.href.split('?')[0];
                const fullUrl = `${baseUrl}?${params.toString()}`;
                
                document.getElementById('chartUrl').textContent = fullUrl;
                
            } catch (error) {
                console.error('URL ìƒì„± ì˜¤ë¥˜:', error);
            }
        }
        
        // í´ë¦½ë³´ë“œì— ë³µì‚¬
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showStatus('ğŸ“‹ URLì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            }).catch(() => {
                showStatus('âš  ë³µì‚¬ ì‹¤íŒ¨', 'error');
            });
        }
        
        // PSD ë‚´ë³´ë‚´ê¸° (Photopea ì—°ë™)
        function exportPSD() {
            if (!currentChart) {
                showStatus('ë¨¼ì € ì°¨íŠ¸ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”', 'error');
                return;
            }
            
            try {
                const svgData = generateSVG();
                convertSVGtoPSD(svgData);
                showStatus('ğŸ¨ Photopeaì—ì„œ PSD ìë™ ì €ì¥ì„ ì‹œì‘í•©ë‹ˆë‹¤', 'success');
            } catch (error) {
                console.error('PSD ë³€í™˜ ì˜¤ë¥˜:', error);
                showStatus('âš  PSD ë³€í™˜ ì‹¤íŒ¨', 'error');
            }
        }
        
        // SVG ìƒì„± (ì‹¤ì œ ì°¨íŠ¸ ìš”ì†Œë“¤ì„ SVGë¡œ ìƒì„±)
        function generateSVG() {
            const showBackground = document.getElementById('showBackground')?.checked !== false;
            const textColor = chartConfig.backgroundColor === 'dark' ? '#FFFFFF' : '#374151';
            const gridColor = chartConfig.backgroundColor === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            
            // Photoshop ìº”ë²„ìŠ¤ & ì°¨íŠ¸ ë°°ì¹˜ (ê°€ë³€ í­ ë°˜ì˜)
            const canvasWidth = 1920;
            const canvasHeight = 1080;
            const baseChartX = 214;
            const chartY = 312;
            const baseChartWidth = 1398;
            const chartHeight = 666;
            const padding = 60;

// í˜„ì¬ ì°¨íŠ¸ íƒ€ì…ì— ë§ëŠ” í­ % ì½ê¸°
            const chartWidthPercent = (() => {
              if (chartConfig.type === 'bar') {
                return parseInt(document.getElementById('chartWidthBar')?.value) || 100;
              }
              if (chartConfig.type === 'line') {
                return parseInt(document.getElementById('chartWidthLine')?.value) || 100;
              }
              return 100; // pie ë“± ê¸°ë³¸ê°’
            })();

// í¼ì„¼íŠ¸ ì ìš© + ì•ˆì „ í´ë¨í”„(ì¢Œìš° ì—¬ë°± ìœ ì§€)
            const desiredChartWidth = Math.round(baseChartWidth * (chartWidthPercent / 100));
            const maxChartWidth = canvasWidth - baseChartX * 2;
            const chartWidth = Math.min(desiredChartWidth, maxChartWidth);

// ê¸°ì¤€ í­ ëŒ€ë¹„ ê°€ìš´ë° ì •ë ¬
            const chartX = baseChartX + Math.round((baseChartWidth - chartWidth) / 2);

// ë‚´ë¶€ ê·¸ë˜í”„ ì˜ì—­
            const graphX = chartX + padding;
            const graphY = chartY + padding;
            const graphWidth = chartWidth - padding * 2;
            const graphHeight = chartHeight - padding * 2;

let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvasWidth}" height="${canvasHeight}" viewBox="0 0 ${canvasWidth} ${canvasHeight}" xmlns="http://www.w3.org/2000/svg">`;

            // ë°°ê²½ (ì˜µì…˜ì— ë”°ë¼)
            if (showBackground) {
                const finalBgColor = chartConfig.backgroundColor === 'dark' ? '#1E3A8A' : '#F8FAFC';
                svgContent += `
    <!-- ë°°ê²½ ê·¸ë£¹ -->
    <g id="background-group">
        <rect width="${canvasWidth}" height="${canvasHeight}" fill="${finalBgColor}"/>
    </g>`;
            }
            
            svgContent += `
    <!-- ì°¨íŠ¸ ì˜ì—­ -->
    <g id="chart-area">
        <rect x="${chartX}" y="${chartY}" width="${chartWidth}" height="${chartHeight}" fill="none" stroke="${textColor}" stroke-width="2"/>
    </g>
`;
            
            // ì°¨íŠ¸ íƒ€ì…ë³„ SVG ìƒì„±
            if (chartConfig.type === 'line') {
                svgContent += generateMultiLineSVG(graphX, graphY, graphWidth, graphHeight, textColor, gridColor);
            } else if (chartConfig.type === 'bar') {
                svgContent += generateMultiBarSVG(graphX, graphY, graphWidth, graphHeight, textColor, gridColor);
            } else if (chartConfig.type === 'pie') {
                svgContent += generateMultiPieSVG(chartX + chartWidth/2, chartY + chartHeight/2, Math.min(chartWidth, chartHeight)/2 - 100, textColor);
            } else if (chartConfig.type === 'table') {
                svgContent += generateTableSVG(chartX, chartY, chartWidth, chartHeight, textColor);
            }
            svgContent += `</svg>`;
            return svgContent;
        }

        // í…Œì´ë¸” SVG ìƒì„± (ì™„ì „íˆ ìƒˆë¡œ êµ¬í˜„)
function generateTableSVG(x, y, width, height, textColor) {
    const tableWidthPercent = parseInt(document.getElementById('tableWidth')?.value) || 100;
    const tableHeightPercent = parseInt(document.getElementById('tableHeight')?.value) || 100;
    
    const adjustedWidth = width * (tableWidthPercent / 100);
    const adjustedHeight = height * (tableHeightPercent / 100);
    const widthOffset = (width - adjustedWidth) / 2;
    const heightOffset = (height - adjustedHeight) / 2;
    
    const finalX = x + widthOffset;
    const finalY = y + heightOffset;
    
    const cellWidth = adjustedWidth / (tableCols + (document.getElementById('showRowNumbers')?.checked ? 1 : 0));
    const cellHeight = adjustedHeight / tableRows;
    
    const borderColor = document.getElementById('borderColor')?.value || '#E5E7EB';
    const borderWidth = parseInt(document.getElementById('borderWidth')?.value) || 3;
    const borderStyle = document.getElementById('borderStyle')?.value || 'solid';
    const textAlign = document.getElementById('textAlign')?.value || 'center';
    const cellPadding = parseInt(document.getElementById('cellPadding')?.value) || 8;
    const headerFontSize = parseInt(document.getElementById('headerFontSize')?.value) || 30;
    const bodyFontSize = parseInt(document.getElementById('bodyFontSize')?.value) || 30;
    
    const headerBgColor = document.getElementById('headerBgColor')?.value || '#3B82F6';
    const headerTextColor = document.getElementById('headerTextColor')?.value || '#FFFFFF';
    
    const stripedRows = document.getElementById('stripedRows')?.checked !== false;
    let oddRowBgColor, oddRowTextColor, evenRowBgColor, evenRowTextColor;
    
    if (stripedRows) {
        oddRowBgColor = document.getElementById('oddRowBgColor')?.value || '#F9FAFB';
        oddRowTextColor = document.getElementById('oddRowTextColor')?.value || '#374151';
        evenRowBgColor = document.getElementById('evenRowBgColor')?.value || '#FFFFFF';
        evenRowTextColor = document.getElementById('evenRowTextColor')?.value || '#374151';
    } else {
        oddRowBgColor = evenRowBgColor = document.getElementById('uniformRowBgColor')?.value || '#FFFFFF';
        oddRowTextColor = evenRowTextColor = document.getElementById('uniformRowTextColor')?.value || '#374151';
    }
    
    const showRowNumbers = document.getElementById('showRowNumbers')?.checked !== false;
    
    let svg = `    <!-- í…Œì´ë¸” ì°¨íŠ¸ ê·¸ë£¹ -->\n    <g id="table-chart-group">\n`;
    
    // ì…€ë³„ë¡œ ë°°ê²½, í…Œë‘ë¦¬, í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
    for (let i = 0; i < tableRows; i++) {
        for (let j = 0; j < tableCols + (showRowNumbers ? 1 : 0); j++) {
            const cellX = finalX + (j * cellWidth);
            const cellY = finalY + (i * cellHeight);
            
            // ë°°ê²½ìƒ‰ ê²°ì •
            let bgColor, currentTextColor;
            if (i === 0) {
                bgColor = headerBgColor;
                currentTextColor = headerTextColor;
            } else {
                if (stripedRows) {
                    if (i % 2 === 1) {
                        bgColor = oddRowBgColor;
                        currentTextColor = oddRowTextColor;
                    } else {
                        bgColor = evenRowBgColor;
                        currentTextColor = evenRowTextColor;
                    }
                } else {
                    bgColor = oddRowBgColor;
                    currentTextColor = oddRowTextColor;
                }
            }
            
            // ì…€ ë°°ê²½ê³¼ í…Œë‘ë¦¬ë¥¼ í•˜ë‚˜ì˜ ì‚¬ê°í˜•ìœ¼ë¡œ ê²°í•©
let strokeDasharray = '';
if (borderStyle === 'dashed') {
    strokeDasharray = ' stroke-dasharray="5,5"';
} else if (borderStyle === 'dotted') {
    strokeDasharray = ' stroke-dasharray="2,2"';
}

svg += `        <rect x="${cellX}" y="${cellY}" width="${cellWidth}" height="${cellHeight}" fill="${bgColor}" stroke="${borderColor}" stroke-width="${borderWidth}"${strokeDasharray}/>\n`;
            // í…ìŠ¤íŠ¸
            let cellText = '';
            if (showRowNumbers && j === 0) {
                cellText = i === 0 ? '#' : i.toString();
            } else {
                const dataCol = showRowNumbers ? j - 1 : j;
                cellText = tableData[i] && tableData[i][dataCol] ? tableData[i][dataCol] : '';
            }
            
            if (cellText) {
                let textX;
                let textAnchor = 'middle';
                if (textAlign === 'left') {
                    textAnchor = 'start';
                    textX = cellX + cellPadding;
                } else if (textAlign === 'right') {
                    textAnchor = 'end';
                    textX = cellX + cellWidth - cellPadding;
                } else {
                    textAnchor = 'middle';
                    textX = cellX + cellWidth / 2;
                }
                
                const fontSize = i === 0 ? headerFontSize : bodyFontSize;
                const fontWeight = i === 0 ? 'bold' : 'normal';
svg += `        <text x="${textX}" y="${cellY + cellHeight / 2 + fontSize/3}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${fontSize}" font-weight="${fontWeight}" fill="${currentTextColor}" text-anchor="${textAnchor}" dominant-baseline="middle">${cellText}</text>\n`;
            }
            
        }
    }
    
    svg += `    </g>\n`;
    return svg;
}
        
        // ë©€í‹° ì„ í˜• ì°¨íŠ¸ SVG ìƒì„± (ìˆ˜ì •ëœ ë²„ì „ - í¬ì¸íŠ¸ ìŠ¤íŠ¸ë¡œí¬ ìƒ‰ìƒ ë¬¸ì œ í•´ê²°)
        function generateMultiLineSVG(x, y, width, height, textColor, gridColor) {
            const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
            const showGridlines = document.getElementById('showGridlines')?.checked !== false;
            const showAxisLabels = document.getElementById('showAxisLabels')?.checked !== false;
            const curvedLines = document.getElementById('curvedLines')?.checked !== false;
            const fillUnderLine = document.getElementById('fillUnderLine')?.checked !== false;
            const customGridlines = true;
            const gridlineInterval = parseFloat(document.getElementById('gridlineInterval')?.value) || 5;
            const yAxisMin = parseFloat(document.getElementById('yAxisMin')?.value) || 0;
            
            // ì°¨íŠ¸ í­ ì¡°ì ˆ
            const chartWidthPercent = parseInt(document.getElementById('chartWidthLine')?.value) || 100;
            const adjustedWidth = width * (chartWidthPercent / 100);
            const widthOffset = (width - adjustedWidth) / 2;
            
            // ëª¨ë“  ì‹œë¦¬ì¦ˆ ë°ì´í„° ìˆ˜ì§‘
            const allSeries = [];
            let allData = [];
            let labels = [];
            
            for (let i = 0; i < numberOfLines; i++) {
                const dataInput = document.getElementById(`lineData${i}`);
                const labelsInput = document.getElementById(`lineLabels${i}`);
                
                if (dataInput) {
                    const data = parsePieData(dataInput.value);
                    if (data.length > 0) {
                        const series = {
                            data: data,
                            color: document.getElementById(`lineColor${i}`)?.value || colorPalette[i % colorPalette.length],
                            pointColor: document.getElementById(`pointColor${i}`)?.value || colorPalette[i % colorPalette.length]
                        };
                        
                        // ìŠ¤íƒ€ì¼ ì„¤ì • - ì „ì—­ ì„¤ì • ì‚¬ìš©
                        series.lineWidth = parseInt(document.getElementById(`lineWidthGlobal`)?.value) || 15;
                        series.pointSize = parseInt(document.getElementById(`pointSizeGlobal`)?.value) || 16;
                        series.pointStrokeWidth = parseInt(document.getElementById(`pointStrokeWidthGlobal`)?.value) || 9;
                        // ğŸ”¥ í•µì‹¬ ìˆ˜ì •: ê° ì„ ì˜ ìƒ‰ìƒê³¼ í¬ì¸íŠ¸ ìŠ¤íŠ¸ë¡œí¬ ìƒ‰ìƒì„ ë™ê¸°í™”
                        series.pointStrokeColor = series.color; // í•­ìƒ í•´ë‹¹ ì„ ì˜ ìƒ‰ìƒê³¼ ë™ì¼í•˜ê²Œ ì„¤ì •
                        series.showPoints = document.getElementById(`showPointsGlobal`)?.checked !== false;
                        series.showPointStroke = document.getElementById(`showPointStrokeGlobal`)?.checked !== false;
                        series.showPointValues = document.getElementById(`showPointValuesGlobal`)?.checked !== false;
                        
                        allSeries.push(series);
                        allData = allData.concat(data);
                        
                        if (i === 0 && labelsInput) {
                            labels = parseLabels(labelsInput.value);
                        }
                    }
                }
            }
            
            if (allSeries.length === 0) return '';
            
            const max = Math.max(...allData);
            const min = Math.min(yAxisMin, Math.min(...allData));
            const range = max - min || 1;
            
            let svg = `    <!-- ì„ í˜• ì°¨íŠ¸ ê·¸ë£¹ -->\n    <g id="line-chart-group">\n`;
            
            // ê²©ìì„  ê·¸ë¦¬ê¸°
            svg += generateGridlinesSVG(x, y, width, height, min, max, range, textColor, gridColor, showGridlines, showAxisLabels, customGridlines, gridlineInterval, false);
            
            // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
            const highlights = document.getElementById('enableHighlight')?.checked ? getHighlightSettings() : [];
            
            // ê° ì‹œë¦¬ì¦ˆ ê·¸ë¦¬ê¸°
            allSeries.forEach((series, seriesIndex) => {
                const leftMargin = 40; // ì™¼ìª½ ì—¬ë°± 40px
                const rightMargin = 40; // ì˜¤ë¥¸ìª½ ì—¬ë°± 40px
                const availableWidth = width - leftMargin - rightMargin;
                
                const points = series.data.map((value, index) => ({
                    x: x + leftMargin + (index * availableWidth / Math.max(series.data.length - 1, 1)),
                    y: y + height - ((value - min) * height / range) * 0.9
                }));
                
                svg += `        <!-- ì„  ì‹œë¦¬ì¦ˆ ${seriesIndex + 1} -->\n        <g id="line-series-${seriesIndex + 1}">\n`;
                
                // ì„  ì•„ë˜ ì±„ìš°ê¸°
                if (fillUnderLine && points.length > 1) {
                    const fillColor = hexToRgba(series.color, 0.25);
                    let pathData = `M ${points[0].x} ${y + height} L ${points[0].x} ${points[0].y}`;
                    
                    if (curvedLines && points.length > 2) {
                        // ê³¡ì„  ì±„ìš°ê¸° ê²½ë¡œ
                        for (let i = 0; i < points.length - 1; i++) {
                            const p0 = points[Math.max(i - 1, 0)];
                            const p1 = points[i];
                            const p2 = points[i + 1];
                            const p3 = points[Math.min(i + 2, points.length - 1)];
                            
                            const cp1x = p1.x + (p2.x - p0.x) * 0.5 / 6;
                            const cp1y = p1.y + (p2.y - p0.y) * 0.5 / 6;
                            const cp2x = p2.x - (p3.x - p1.x) * 0.5 / 6;
                            const cp2y = p2.y - (p3.y - p1.y) * 0.5 / 6;
                            
                            pathData += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p2.x} ${p2.y}`;
                        }
                    } else {
                        // ì§ì„  ì±„ìš°ê¸°
                        for (let i = 1; i < points.length; i++) {
                            pathData += ` L ${points[i].x} ${points[i].y}`;
                        }
                    }
                    
                    pathData += ` L ${points[points.length - 1].x} ${y + height} Z`;
                    svg += `            <path d="${pathData}" fill="${fillColor}" stroke="none"/>\n`;
                }
                
                // ì„  ê·¸ë¦¬ê¸°
                if (points.length > 1) {
                    let pathData = `M ${points[0].x} ${points[0].y}`;
                    if (curvedLines && points.length > 2) {
                        // ë² ì§€ì–´ ê³¡ì„  ê²½ë¡œ ìƒì„±
                        for (let i = 0; i < points.length - 1; i++) {
                            const p0 = points[Math.max(i - 1, 0)];
                            const p1 = points[i];
                            const p2 = points[i + 1];
                            const p3 = points[Math.min(i + 2, points.length - 1)];
                            
                            const cp1x = p1.x + (p2.x - p0.x) * 0.5 / 6;
                            const cp1y = p1.y + (p2.y - p0.y) * 0.5 / 6;
                            const cp2x = p2.x - (p3.x - p1.x) * 0.5 / 6;
                            const cp2y = p2.y - (p3.y - p1.y) * 0.5 / 6;
                            
                            pathData += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p2.x} ${p2.y}`;
                        }
                    } else {
                        for (let i = 1; i < points.length; i++) {
                            pathData += ` L ${points[i].x} ${points[i].y}`;
                        }
                    }
                    svg += `            <path d="${pathData}" stroke="${series.color}" stroke-width="${series.lineWidth}" fill="none"/>\n`;
                }
                
                // í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
                if (series.showPoints) {
                    points.forEach((point, index) => {
                        const isHighlighted = highlights.some(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const highlight = highlights.find(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const currentPointSize = isHighlighted ? series.pointSize * 1.5 : series.pointSize;
                        const currentPointColor = isHighlighted ? highlight.color : series.pointColor;
                        
                        if (series.showPointStroke && series.pointStrokeWidth > 0) {
                            svg += `            <circle cx="${point.x}" cy="${point.y}" r="${currentPointSize}" fill="${currentPointColor}" stroke="${series.pointStrokeColor}" stroke-width="${series.pointStrokeWidth}"/>\n`;
                        } else {
                            svg += `            <circle cx="${point.x}" cy="${point.y}" r="${currentPointSize}" fill="${currentPointColor}"/>\n`;
                        }
                    });
                }
                
                // í¬ì¸íŠ¸ ê°’ í‘œì‹œ
                if (series.showPointValues) {
                    points.forEach((point, index) => {
                        const isHighlighted = highlights.some(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const highlight = highlights.find(h => h.index === index + 1 && h.series === seriesIndex + 1);
                        const currentTextColor = isHighlighted ? highlight.color : series.color; // ì„  ìƒ‰ìƒ ì‚¬ìš©
                        const currentPointSize = isHighlighted ? series.pointSize * 1.5 : series.pointSize;
                        
                        const fontSize = parseInt(document.getElementById('lineValueFontSizeGlobal')?.value) || 55;
svg += `            <text x="${point.x}" y="${point.y - currentPointSize - 10}" font-family="AppleSDGothicNeo-Regular" font-size="${fontSize}" font-weight="bold" fill="${currentTextColor}" text-anchor="middle">${getDisplayValue('line', seriesIndex, index, series.data[index])}</text>\n`;
                    });
                }
                
                svg += `        </g>\n`;
            });
            
            // ë ˆì´ë¸” ê·¸ë¦¬ê¸°
            if (allSeries.length > 0 && labels.length > 0) {
                const firstSeries = allSeries[0];
                const leftMargin = 40;
                const rightMargin = 40;
                const availableWidth = width - leftMargin - rightMargin;
                
                const points = firstSeries.data.map((value, index) => ({
                    x: x + leftMargin + (index * availableWidth / Math.max(firstSeries.data.length - 1, 1)),
                    y: y + height - ((value - min) * height / range) * 0.9
                }));
                
                svg += `        <!-- ë ˆì´ë¸” ê·¸ë£¹ -->\n        <g id="labels-group">\n`;
                points.forEach((point, index) => {
                    const label = labels[index] || `${index + 1}`;
                    svg += `            <text x="${point.x}" y="${y + height + 25}" font-family="AppleSDGothicNeo-Regular" font-size="30" fill="${textColor}" text-anchor="middle">${label}</text>\n`;
                });
                svg += `        </g>\n`;
            }
            
            svg += `    </g>\n`;
            return svg;
        }
        
        // ë©€í‹° ë§‰ëŒ€ ì°¨íŠ¸ SVG ìƒì„±
        function generateMultiBarSVG(x, y, width, height, textColor, gridColor) {
            const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
            const showGridlines = document.getElementById('showGridlines')?.checked !== false;
            const showAxisLabels = document.getElementById('showAxisLabels')?.checked !== false;
            const horizontalBars = document.getElementById('horizontalBars')?.checked !== false;
            const stackedBars = document.getElementById('stackedBars')?.checked !== false;
            const showBarValues = document.getElementById('showBarValues')?.checked !== false;
            const customGridlines = true;
            const gridlineInterval = parseFloat(document.getElementById('gridlineInterval')?.value) || 5;
            const barWidthPx = parseInt(document.getElementById('barWidth')?.value) || 110;
            const yAxisMin = parseFloat(document.getElementById('yAxisMinBar')?.value) || 0;
            const barValueFontSize = parseInt(document.getElementById('barValueFontSize')?.value) || 55;
            const useArrow = document.getElementById('arrowBars')?.checked || false;
            
            // ì°¨íŠ¸ í­ ì¡°ì ˆ (Canvasì™€ ë™ì¼í•˜ê²Œ ì¶”ê°€)
            const chartWidthPercent = parseInt(document.getElementById('chartWidthBar')?.value) || 100;
            const adjustedWidth = width * (chartWidthPercent / 100);
            const widthOffset = (width - adjustedWidth) / 2;
            
            // ëª¨ë“  ì‹œë¦¬ì¦ˆ ë°ì´í„° ìˆ˜ì§‘
            const allSeries = [];
            let allData = [];
            let labels = [];
            let maxDataLength = 0;
            
            for (let i = 0; i < numberOfBars; i++) {
                const dataInput = document.getElementById(`barData${i}`);
                const labelsInput = document.getElementById(`barLabels${i}`);
                const useIndividualColors = document.getElementById(`useIndividualBarColors${i}`)?.checked || false;
                
                if (dataInput) {
                    const data = parsePieData(dataInput.value);
                    if (data.length > 0) {
                        const series = {
                            data: data,
                            color: document.getElementById(`barColor${i}`)?.value || colorPalette[i % colorPalette.length],
                            useIndividualColors: useIndividualColors,
                            individualColors: []
                        };
                        
                        // ê°œë³„ ìƒ‰ìƒ ì„¤ì •ì´ í™œì„±í™”ëœ ê²½ìš° ê° ë§‰ëŒ€ë³„ ìƒ‰ìƒ ìˆ˜ì§‘
                        if (useIndividualColors) {
                            for (let j = 0; j < data.length; j++) {
                                const colorInput = document.getElementById(`individualBarColor${i}_${j}`);
                                series.individualColors.push(colorInput ? colorInput.value : colorPalette[j % colorPalette.length]);
                            }
                        }
                        
                        allSeries.push(series);
                        allData = allData.concat(data);
                        maxDataLength = Math.max(maxDataLength, data.length);
                        
                        if (i === 0 && labelsInput) {
                            labels = parseLabels(labelsInput.value);
                        }
                    }
                }
            }
            
            if (allSeries.length === 0) return '';
            
            let max, min, range;
            
            if (stackedBars) {
                const stackedTotals = [];
                for (let i = 0; i < maxDataLength; i++) {
                    let total = 0;
                    allSeries.forEach(series => {
                        if (i < series.data.length) {
                            total += series.data[i];
                        }
                    });
                    stackedTotals.push(total);
                }
                max = Math.max(...stackedTotals, 0); // ìµœëŒ€ê°’ì´ 0ë³´ë‹¤ ì‘ìœ¼ë©´ 0ì„ ìµœëŒ€ê°’ìœ¼ë¡œ
                min = Math.min(yAxisMin, 0);
            } else {
                const dataMax = Math.max(...allData);
                const dataMin = Math.min(...allData);
                max = Math.max(dataMax, 0); // ìµœëŒ€ê°’ì´ 0ë³´ë‹¤ ì‘ìœ¼ë©´ 0ì„ ìµœëŒ€ê°’ìœ¼ë¡œ
                min = Math.min(yAxisMin, dataMin); // ì‹¤ì œ ë°ì´í„° ìµœì†Ÿê°’ê³¼ ì‚¬ìš©ì ì„¤ì • ìµœì†Ÿê°’ ì¤‘ ë” ì‘ì€ ê°’
            }
            range = max - min || 1;
            
            let svg = `    <!-- ë§‰ëŒ€ ì°¨íŠ¸ ê·¸ë£¹ -->\n    <g id="bar-chart-group">\n`;
            
            // ê²©ìì„  ê·¸ë¦¬ê¸°
            svg += generateGridlinesSVG(x, y, width, height, min, max, range, textColor, gridColor, showGridlines, showAxisLabels, customGridlines, gridlineInterval, horizontalBars, adjustedWidth, widthOffset);
            
            // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
            const highlights = document.getElementById('enableHighlight')?.checked ? getHighlightSettings() : [];
            
            if (stackedBars) {
    // ëˆ„ì  ë§‰ëŒ€ ê·¸ë¦¬ê¸°
    svg += `        <!-- ëˆ„ì  ë§‰ëŒ€ ê·¸ë£¹ -->\n        <g id="stacked-bars-group">\n`;
    const barSpacing = horizontalBars ? height / maxDataLength : width / maxDataLength;
    const actualBarWidth = Math.min(barWidthPx, barSpacing * 0.8);
    
    for (let dataIndex = 0; dataIndex < maxDataLength; dataIndex++) {
        let cumulativeValue = 0;
        
        allSeries.forEach((series, seriesIndex) => {
            if (dataIndex < series.data.length) {
                const value = series.data[dataIndex];
                const isHighlighted = highlights.some(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                const highlight = highlights.find(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                
                // ìƒ‰ìƒ ê²°ì • (ê°œë³„ ìƒ‰ìƒ > ê°•ì¡° ìƒ‰ìƒ > ì‹œë¦¬ì¦ˆ ìƒ‰ìƒ ìˆœ)
                let currentColor;
                if (series.useIndividualColors && series.individualColors[dataIndex]) {
                    currentColor = series.individualColors[dataIndex];
                } else if (isHighlighted) {
                    currentColor = highlight.color;
                } else {
                    currentColor = series.color;
                }
                
                if (horizontalBars) {
                    const zeroX = x + widthOffset + ((-min) / range) * adjustedWidth * 0.9;
                    const barWidth = Math.abs((value / range) * adjustedWidth * 0.9);
                    const barY = y + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
                    let barX;
                    
                    if (value >= 0) {
                        barX = zeroX + ((cumulativeValue >= 0 ? cumulativeValue : 0) / range) * adjustedWidth * 0.9;
                    } else {
                        barX = zeroX - barWidth + ((cumulativeValue < 0 ? cumulativeValue : 0) / range) * adjustedWidth * 0.9;
                    }
                    
                    if (useArrow) {
    svg += generateArrowSVG(barX, barY, barWidth, actualBarWidth, currentColor, true, (value < 0));
} else {
    svg += `            <rect x="${barX}" y="${barY}" width="${barWidth}" height="${actualBarWidth}" fill="${currentColor}"/>\n`;
}
                    
                    if (showBarValues) {
    const textX = barX + barWidth + 8;  // ë§‰ëŒ€ ëì—ì„œ 8px ë–¨ì–´ì§„ ê³³
    svg += `            <text x="${textX}" y="${barY + actualBarWidth/2 + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${barValueFontSize}" font-weight="bold" text-anchor="start" fill="${currentColor}">${getDisplayValue('bar', seriesIndex, dataIndex, value)}</text>\n`;
}
                } else {
                    const zeroY = y + height - ((-min) / range) * height * 0.9;
                    const barHeight = Math.abs((value / range) * height * 0.9);
                    const barX = x + widthOffset + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
                    let barY;
                    
                    if (value >= 0) {
                        barY = zeroY - barHeight - ((cumulativeValue >= 0 ? cumulativeValue : 0) / range) * height * 0.9;
                    } else {
                        barY = zeroY + ((cumulativeValue < 0 ? Math.abs(cumulativeValue) : 0) / range) * height * 0.9;
                    }
                    
                    if (useArrow) {
    svg += generateArrowSVG(barX, barY, actualBarWidth, barHeight, currentColor, false, (value < 0));
} else {
    svg += `            <rect x="${barX}" y="${barY}" width="${actualBarWidth}" height="${barHeight}" fill="${currentColor}"/>\n`;
}
                    
                    if (showBarValues) {
                        const textY = value >= 0 ? barY - 8 : barY + barHeight + barValueFontSize + 5;
                        svg += `            <text x="${barX + actualBarWidth/2}" y="${textY}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${barValueFontSize}" text-anchor="middle" font-weight="bold" fill="${currentColor}">${getDisplayValue('bar', seriesIndex, dataIndex, value)}</text>\n`;
                    }
                }
                
                cumulativeValue += value;
            }
        });
    }
    svg += `        </g>\n`;
            } else {
                // ì¼ë°˜ ë§‰ëŒ€ ê·¸ë¦¬ê¸°
                svg += `        <!-- ë§‰ëŒ€ ê·¸ë£¹ -->\n        <g id="bars-group">\n`;
                const barSpacing = horizontalBars ? height / maxDataLength : adjustedWidth / maxDataLength;
                const actualBarWidth = Math.min(barWidthPx, barSpacing * 0.8);
                const seriesSpacing = parseInt(document.getElementById('barSpacing')?.value) || 5;
                const seriesBarWidth = numberOfBars > 1 ? (actualBarWidth - (seriesSpacing * (numberOfBars - 1))) / numberOfBars : actualBarWidth;
                
                allSeries.forEach((series, seriesIndex) => {
                    series.data.forEach((value, dataIndex) => {
                        const isHighlighted = highlights.some(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                        const highlight = highlights.find(h => h.index === dataIndex + 1 && h.series === seriesIndex + 1);
                        
                        // ìƒ‰ìƒ ê²°ì • (ê°œë³„ ìƒ‰ìƒ > ê°•ì¡° ìƒ‰ìƒ > ì‹œë¦¬ì¦ˆ ìƒ‰ìƒ ìˆœ)
                        let currentColor;
                        if (series.useIndividualColors && series.individualColors[dataIndex]) {
                            currentColor = series.individualColors[dataIndex];
                        } else if (isHighlighted) {
                            currentColor = highlight.color;
                        } else {
                            currentColor = series.color;
                        }
                        
                        if (horizontalBars) {
    const zeroX = x + widthOffset + ((-min) / range) * adjustedWidth * 0.9;
    const barWidth = Math.abs((value / range) * adjustedWidth * 0.9);
    const baseY = y + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
    const barY = baseY + (seriesIndex * (seriesBarWidth + seriesSpacing));
    const barX = value >= 0 ? zeroX : zeroX - barWidth;
    
    if (useArrow) {
    svg += generateArrowSVG(barX, barY, barWidth, seriesBarWidth, currentColor, true, (value < 0));
} else {
    svg += `            <rect x="${barX}" y="${barY}" width="${barWidth}" height="${seriesBarWidth}" fill="${currentColor}"/>\n`;
}
    if (showBarValues) {
    const textX = barX + barWidth + 8;  // ë§‰ëŒ€ ëì—ì„œ 8px ë–¨ì–´ì§„ ê³³
    svg += `            <text x="${textX}" y="${barY + seriesBarWidth/2 + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${barValueFontSize}" font-weight="bold" text-anchor="start" fill="${currentColor}">${getDisplayValue('bar', seriesIndex, dataIndex, value)}</text>\n`;
}
} else {
    const zeroY = y + height - ((-min) / range) * height * 0.9;
    const barHeight = Math.abs((value / range) * height * 0.9);
    const baseX = x + widthOffset + (dataIndex * barSpacing) + (barSpacing - actualBarWidth) / 2;
    const barX = baseX + (seriesIndex * (seriesBarWidth + seriesSpacing));
    const barY = value >= 0 ? zeroY - barHeight : zeroY;
    
    if (useArrow) {
    svg += generateArrowSVG(barX, barY, seriesBarWidth, barHeight, currentColor, false, (value < 0));
} else {
    svg += `            <rect x="${barX}" y="${barY}" width="${seriesBarWidth}" height="${barHeight}" fill="${currentColor}"/>\n`;
}

                            
                            if (showBarValues) {
    const textY = value >= 0 ? barY - 8 : barY + barHeight + barValueFontSize + 5;
    svg += `            <text x="${barX + seriesBarWidth/2}" y="${textY}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${barValueFontSize}" text-anchor="middle" font-weight="bold" fill="${currentColor}">${getDisplayValue('bar', seriesIndex, dataIndex, value)}</text>\n`;
}
                        }
                    });
                });
                svg += `        </g>\n`;
            }
            
            // ë ˆì´ë¸” ê·¸ë¦¬ê¸°
            if (labels.length > 0) {
                svg += `        <!-- ë ˆì´ë¸” ê·¸ë£¹ -->\n        <g id="labels-group">\n`;
                for (let i = 0; i < Math.min(labels.length, maxDataLength); i++) {
                    const label = labels[i];
                    
                    if (horizontalBars) {
                        const barSpacing = height / maxDataLength;
                        const barY = y + (i * barSpacing) + barSpacing / 2;
                        svg += `            <text x="${x + widthOffset - 10}" y="${barY + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="30" fill="${textColor}" text-anchor="end">${label}</text>\n`;
                    } else {
                        const barSpacing = adjustedWidth / maxDataLength;
                        const barX = x + widthOffset + (i * barSpacing) + barSpacing / 2;
                        svg += `            <text x="${barX}" y="${y + height + 25}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="30" fill="${textColor}" text-anchor="middle">${label}</text>\n`;
                    }
                }
                svg += `        </g>\n`;
            }
            
            svg += `    </g>\n`;
            return svg;
        }
        
        
        // SVG arrow path generator (with negative direction support)
        function generateArrowSVG(x, y, width, height, color, isHorizontal, pointNegative=false) {
            const rawW = parseInt(document.getElementById('arrowHeadWidth')?.value) || 40;
            const rawH = parseInt(document.getElementById('arrowHeadHeight')?.value) || 30;
            const headW = Math.max(5, Math.min(rawW, Math.max(5, isHorizontal ? width*0.6 : width*2)));
            const headH = Math.max(5, Math.min(rawH, Math.max(5, isHorizontal ? height*2 : height*0.6)));
            let d = '';
            if (isHorizontal) {
                if (!pointNegative) {
                    d = `M ${x} ${y} L ${x + width - headW} ${y} L ${x + width - headW} ${y + (height - headH)/2} L ${x + width} ${y + height/2} L ${x + width - headW} ${y + (height + headH)/2} L ${x + width - headW} ${y + height} L ${x} ${y + height} Z`;
                } else {
                    d = `M ${x + width} ${y} L ${x + headW} ${y} L ${x + headW} ${y + (height - headH)/2} L ${x} ${y + height/2} L ${x + headW} ${y + (height + headH)/2} L ${x + headW} ${y + height} L ${x + width} ${y + height} Z`;
                }
            } else {
                if (!pointNegative) {
                    d = `M ${x} ${y + height} L ${x} ${y + headH} L ${x + (width - headW)/2} ${y + headH} L ${x + width/2} ${y} L ${x + (width + headW)/2} ${y + headH} L ${x + width} ${y + headH} L ${x + width} ${y + height} Z`;
                } else {
                    d = `M ${x} ${y} L ${x} ${y + height - headH} L ${x + (width - headW)/2} ${y + height - headH} L ${x + width/2} ${y + height} L ${x + (width + headW)/2} ${y + height - headH} L ${x + width} ${y + height - headH} L ${x + width} ${y} Z`;
                }
            }
            return `            <path d="${d}" fill="${color}"/>
`;
        }
    
        // ë©€í‹° íŒŒì´ ì°¨íŠ¸ SVG ìƒì„±
        function generateMultiPieSVG(centerX, centerY, radius, textColor) {
            const numberOfPies = parseInt(document.getElementById('numberOfPies')?.value) || 1;
            const pieWidth = 1398 / numberOfPies;
            const pieRadius = Math.min(pieWidth, 666) / 2 - 100;
            const showPieLabels = document.getElementById('showPieLabels')?.checked !== false;
            const showPieValues = document.getElementById('showPieValues')?.checked !== false;
            
            let svg = `    <!-- íŒŒì´ ì°¨íŠ¸ ê·¸ë£¹ -->\n    <g id="pie-chart-group">\n`;
            
            // ê°•ì¡° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
            const highlights = document.getElementById('enableHighlight')?.checked ? getHighlightSettings() : [];
            
            for (let pieIndex = 0; pieIndex < numberOfPies; pieIndex++) {
                const dataInput = document.getElementById(`pieData${pieIndex}`);
                const labelsInput = document.getElementById(`pieLabels${pieIndex}`);
                const isDonutInput = document.getElementById(`isDonut${pieIndex}`);
                const isHalfPieInput = document.getElementById(`isHalfPie${pieIndex}`);
                
                if (!dataInput) continue;
                
                const data = parsePieData(dataInput.value); // parsePieData ì‚¬ìš©
                const labels = parseLabels(labelsInput ? labelsInput.value : '');
                
                if (data.length === 0) continue;
                
                const pieCenterX = 214 + (pieIndex * pieWidth) + pieWidth / 2;
                const pieCenterY = centerY;
                const isDonut = isDonutInput ? isDonutInput.checked : false;
                const isHalfPie = isHalfPieInput ? isHalfPieInput.checked : false;
                const donutThickness = parseInt(document.getElementById(`donutThickness${pieIndex}`)?.value) || 40;
                const innerRadius = isDonut ? pieRadius * ((100 - donutThickness) / 100) : 0;
                
                const total = data.reduce((sum, value) => sum + value, 0);
                let currentAngle = isHalfPie ? -Math.PI : -Math.PI / 2; // Half PieëŠ” -Ï€ë¶€í„° ì‹œì‘
                const totalAngle = isHalfPie ? Math.PI : Math.PI * 2; // Half PieëŠ” Ï€(180ë„)ë§Œ ì‚¬ìš©
                
                svg += `        <!-- íŒŒì´ ì°¨íŠ¸ ${pieIndex + 1} -->\n        <g id="pie-${pieIndex + 1}">\n`;
                
                // ë°°ê²½ shape layer ì¶”ê°€ (Half Pie ì„¤ì •ì— ë§ì¶°ì„œ)
                if (isHalfPie) {
                    if (isDonut) {
                        // Half Pie ë„ë„› ë°°ê²½
                        const halfDonutPath = `M ${pieCenterX - pieRadius},${pieCenterY}
                            A ${pieRadius},${pieRadius} 0 0,1 ${pieCenterX + pieRadius},${pieCenterY}
                            L ${pieCenterX + innerRadius},${pieCenterY}
                            A ${innerRadius},${innerRadius} 0 0,0 ${pieCenterX - innerRadius},${pieCenterY}
                            Z`;
                        svg += `            <path d="${halfDonutPath}" fill="#e5e7eb" opacity="0.3"/>\n`;
                    } else {
                        // Half Pie ì› ë°°ê²½
                        const halfCirclePath = `M ${pieCenterX - pieRadius},${pieCenterY}
                            A ${pieRadius},${pieRadius} 0 0,1 ${pieCenterX + pieRadius},${pieCenterY}
                            Z`;
                        svg += `            <path d="${halfCirclePath}" fill="#e5e7eb" opacity="0.3"/>\n`;
                    }
                } else {
                    // ì™„ì „í•œ ì›/ë„ë„› ë°°ê²½ (ê¸°ì¡´ ë¡œì§)
                    if (isDonut) {
                        // ë„ë„› ë°°ê²½ì„ í•˜ë‚˜ì˜ pathë¡œ ìƒì„± (ê°€ìš´ë° ëš«ë¦° í•˜ë‚˜ì˜ ë ˆì´ì–´)
                        const donutPath = `M ${pieCenterX},${pieCenterY - pieRadius} 
                            A ${pieRadius},${pieRadius} 0 1,1 ${pieCenterX},${pieCenterY + pieRadius}
                            A ${pieRadius},${pieRadius} 0 1,1 ${pieCenterX},${pieCenterY - pieRadius} Z
                            M ${pieCenterX},${pieCenterY - innerRadius}
                            A ${innerRadius},${innerRadius} 0 1,0 ${pieCenterX},${pieCenterY + innerRadius}
                            A ${innerRadius},${innerRadius} 0 1,0 ${pieCenterX},${pieCenterY - innerRadius} Z`;
                        svg += `            <path d="${donutPath}" fill="#e5e7eb" opacity="0.3" fill-rule="evenodd"/>\n`;
                    } else {
                        // ì™„ì „í•œ ì› ë°°ê²½
                        svg += `            <circle cx="${pieCenterX}" cy="${pieCenterY}" r="${pieRadius}" fill="#e5e7eb" opacity="0.3"/>\n`;
                    }
                }
                
                // íŒŒì´ ì¡°ê° ê·¸ë¦¬ê¸°
                data.forEach((value, index) => {
                    const sliceAngle = (value / total) * totalAngle; // Half Pieì˜ ê²½ìš° Ï€ë§Œ ì‚¬ìš©
                    
                    const colorInput = document.getElementById(`pieColor${pieIndex}_${index}`);
                    let color = colorInput ? colorInput.value : pieColorPalette[index % pieColorPalette.length];
                    
                    // ê°•ì¡° ê¸°ëŠ¥ í™•ì¸
                    const isHighlighted = highlights.some(h => h.index === index + 1 && h.series === pieIndex + 1);
                    if (isHighlighted) {
                        const highlight = highlights.find(h => h.index === index + 1 && h.series === pieIndex + 1);
                        color = highlight.color;
                    }
                    
                    const startX = pieCenterX + Math.cos(currentAngle) * pieRadius;
                    const startY = pieCenterY + Math.sin(currentAngle) * pieRadius;
                    const endX = pieCenterX + Math.cos(currentAngle + sliceAngle) * pieRadius;
                    const endY = pieCenterY + Math.sin(currentAngle + sliceAngle) * pieRadius;
                    
                    const largeArcFlag = sliceAngle > Math.PI ? 1 : 0;
                    
                    let pathData;
                    if (isDonut) {
                        const innerStartX = pieCenterX + Math.cos(currentAngle) * innerRadius;
                        const innerStartY = pieCenterY + Math.sin(currentAngle) * innerRadius;
                        const innerEndX = pieCenterX + Math.cos(currentAngle + sliceAngle) * innerRadius;
                        const innerEndY = pieCenterY + Math.sin(currentAngle + sliceAngle) * innerRadius;
                        
                        pathData = `M ${startX} ${startY} A ${pieRadius} ${pieRadius} 0 ${largeArcFlag} 1 ${endX} ${endY} L ${innerEndX} ${innerEndY} A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY} Z`;
                    } else {
                        pathData = `M ${pieCenterX} ${pieCenterY} L ${startX} ${startY} A ${pieRadius} ${pieRadius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;
                    }
                    
                    svg += `            <path d="${pathData}" fill="${color}"/>\n`;
                    
                    
                    // ë ˆì´ë¸” í‘œì‹œ (í¼ì„¼íŠ¸ ì œì™¸)
if (showPieLabels) {
    const labelAngle = currentAngle + sliceAngle / 2;
    const labelRadius = pieRadius + (isHalfPie ? 30 : 50);
    const labelX = pieCenterX + Math.cos(labelAngle) * labelRadius;
    const labelY = pieCenterY + Math.sin(labelAngle) * labelRadius;
    
    const label = labels[index] || `ì¡°ê° ${index + 1}`;
    const fontSize = isHighlighted ? '60' : '70';
    const fontWeight = isHighlighted ? 'bold' : 'normal';
    
    // ë ˆì´ë¸” í…ìŠ¤íŠ¸ë§Œ í‘œì‹œ
    svg += `            <text x="${labelX}" y="${labelY}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${fontSize}" font-weight="${fontWeight}" fill="${textColor}" text-anchor="middle">${label}</text>\n`;
}
                    
                    // ê°’ë„ í‘œì‹œ
                    if (showPieValues) {
                        const valueRadius = pieRadius + (isHalfPie ? 15 : 30); // Half PieëŠ” ì¡°ê¸ˆ ë” ê°€ê¹Œì´
                        const valueX = pieCenterX + Math.cos(currentAngle + sliceAngle / 2) * valueRadius;
                        const valueY = pieCenterY + Math.sin(currentAngle + sliceAngle / 2) * valueRadius;
                        
                        const baseFontSize = parseInt(document.getElementById('pieValueFontSize')?.value) || 60;
                        const valueSize = isHighlighted ? baseFontSize + 10 : baseFontSize;
                        svg += `            <text x="${valueX}" y="${valueY}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="${valueSize}" font-weight="bold" fill="${color}" text-anchor="middle">${getDisplayValue('pie', pieIndex, index, value)}</text>\n`;
                    }
                    
                    currentAngle += sliceAngle;
                });
                
                svg += `        </g>\n`;
            }
            
            svg += `    </g>\n`;
            return svg;
        }
        
        // ë°ì´í„°ê°€ ëª¨ë‘ ì •ìˆ˜ì¸ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
        function areAllDataValuesInteger(chartType) {
            let allValues = [];
            
            if (chartType === 'line') {
                const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
                for (let i = 0; i < numberOfLines; i++) {
                    const dataInput = document.getElementById(`lineData${i}`);
                    if (dataInput) {
                        const data = parsePieData(dataInput.value);
                        allValues = allValues.concat(data);
                    }
                }
            } else if (chartType === 'bar') {
                const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
                for (let i = 0; i < numberOfBars; i++) {
                    const dataInput = document.getElementById(`barData${i}`);
                    if (dataInput) {
                        const data = parsePieData(dataInput.value);
                        allValues = allValues.concat(data);
                    }
                }
            }
            
            // ëª¨ë“  ê°’ì´ ì •ìˆ˜ì¸ì§€ í™•ì¸
            return allValues.every(value => Number.isInteger(value));
        }
        
        // í˜„ì¬ ì°¨íŠ¸ì˜ ëª¨ë“  ë°ì´í„°ì—ì„œ ìˆ«ìê°’ê³¼ í•œê¸€ í‘œí˜„ ë§¤í•‘ ìƒì„±
function createValueToKoreanMap() {
    const mapping = new Map();
    
    if (chartConfig.type === 'line') {
        const numberOfLines = parseInt(document.getElementById('numberOfLines')?.value) || 1;
        for (let i = 0; i < numberOfLines; i++) {
            const dataInput = document.getElementById(`lineData${i}`);
            if (dataInput) {
                const tokens = __splitToTokens(dataInput.value);
                tokens.forEach(token => {
                    const numericValue = parseKoreanMixedNumber(token);
                    if (!isNaN(numericValue)) {
                        mapping.set(numericValue, token);
                    }
                });
            }
        }
    } else if (chartConfig.type === 'bar') {
        const numberOfBars = parseInt(document.getElementById('numberOfBars')?.value) || 1;
        for (let i = 0; i < numberOfBars; i++) {
            const dataInput = document.getElementById(`barData${i}`);
            if (dataInput) {
                const tokens = __splitToTokens(dataInput.value);
                tokens.forEach(token => {
                    const numericValue = parseKoreanMixedNumber(token);
                    if (!isNaN(numericValue)) {
                        mapping.set(numericValue, token);
                    }
                });
            }
        }
    }
    
    return mapping;
}

// ê°’ì„ ì ì ˆí•œ í˜•ì‹ìœ¼ë¡œ í¬ë§·í•˜ëŠ” í•¨ìˆ˜ (í•œê¸€ í‘œí˜„ ìš°ì„  ì‚¬ìš©)
function formatAxisValue(value, useInteger = false) {
    // í•œê¸€ ë³€í™˜ ë¡œì§ ì œê±°í•˜ê³  ê¸°ë³¸ ìˆ«ì í¬ë§·ë§Œ ì‚¬ìš©
    if (useInteger || Number.isInteger(value)) {
        return Math.round(value).toString();
    } else {
        // Fix floating point precision issues and format with appropriate decimal places
        // Use toFixed with more precision, then remove trailing zeros
        const fixed = parseFloat(value.toFixed(10));
        return fixed.toString();
    }
}

        
        // ê²©ìì„  SVG ìƒì„± (ê³µí†µ í•¨ìˆ˜)
        function generateGridlinesSVG(x, y, width, height, min, max, range, textColor, gridColor, showGridlines, showAxisLabels, customGridlines, gridlineInterval, horizontalBars = false, adjustedWidth = null, widthOffset = 0) {
            let svg = `        <!-- ê²©ìì„ ê³¼ ì¶• ê·¸ë£¹ -->\n        <g id="grid-and-axes-group">\n`;
            
            // adjustedWidthê°€ nullì´ë©´ width ì‚¬ìš© (line chart ë“±)
            if (adjustedWidth === null) {
                adjustedWidth = width;
                widthOffset = 0;
            }
            
            // ë°ì´í„°ê°€ ëª¨ë‘ ì •ìˆ˜ì¸ì§€ í™•ì¸
            const useIntegerFormat = areAllDataValuesInteger(chartConfig.type);
            
            // ê²©ìì„ 
            if (showGridlines) {
                if (customGridlines) {
                    const numLinesUp = Math.floor(max / gridlineInterval);
                    const numLinesDown = Math.floor(Math.abs(min) / gridlineInterval);
                    
                    // ì–‘ìˆ˜ ë°©í–¥ ê²©ìì„ 
                    for (let i = 0; i <= numLinesUp; i++) {
                        const value = parseFloat((i * gridlineInterval).toFixed(10));
                        if (value > max) break;
                        
                        const strokeWidth = value === 0 ? "2" : "0.5";
                        
                        if (horizontalBars) {
                            const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
                            svg += `            <line x1="${gridX}" y1="${y}" x2="${gridX}" y2="${y + height}" stroke="${gridColor}" stroke-width="${strokeWidth}"/>\n`;
                        } else {
                            const gridY = y + height - ((value - min) * height / range) * 0.9;
                            svg += `            <line x1="${x + widthOffset}" y1="${gridY}" x2="${x + widthOffset + adjustedWidth}" y2="${gridY}" stroke="${gridColor}" stroke-width="${strokeWidth}"/>\n`;
                        }
                    }
                    
                    // ìŒìˆ˜ ë°©í–¥ ê²©ìì„ 
                    for (let i = 1; i <= numLinesDown; i++) {
                        const value = parseFloat((-i * gridlineInterval).toFixed(10));
                        if (value < min) break;
                        
                        if (horizontalBars) {
                            const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
                            svg += `            <line x1="${gridX}" y1="${y}" x2="${gridX}" y2="${y + height}" stroke="${gridColor}" stroke-width="0.5"/>\n`;
                        } else {
                            const gridY = y + height - ((value - min) * height / range) * 0.9;
                            svg += `            <line x1="${x + widthOffset}" y1="${gridY}" x2="${x + widthOffset + adjustedWidth}" y2="${gridY}" stroke="${gridColor}" stroke-width="0.5"/>\n`;
                        }
                    }
                } else {
                    // ê¸°ë³¸ ê²©ìì„  - ìŒìˆ˜ê°€ ìˆì„ ê²½ìš° 0ì„ í¬í•¨í•˜ë„ë¡ ìˆ˜ì •
                    if (min < 0 && max > 0) {
                        // ìŒìˆ˜ì™€ ì–‘ìˆ˜ê°€ ëª¨ë‘ ìˆëŠ” ê²½ìš° - 0ì„ ì¤‘ì‹¬ìœ¼ë¡œ ê²©ìì„  ìƒì„±
                        const absMax = Math.max(Math.abs(min), Math.abs(max));
                        const step = absMax / 3;
                        
                        for (let i = -3; i <= 3; i++) {
                            const value = i * step;
                            if (value < min || value > max) continue;
                            
                            const strokeWidth = value === 0 ? "2" : "0.5";
                            
                            if (horizontalBars) {
                                const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
                                svg += `            <line x1="${gridX}" y1="${y}" x2="${gridX}" y2="${y + height}" stroke="${gridColor}" stroke-width="${strokeWidth}"/>\n`;
                            } else {
                                const gridY = y + height - ((value - min) * height / range) * 0.9;
                                svg += `            <line x1="${x + widthOffset}" y1="${gridY}" x2="${x + widthOffset + adjustedWidth}" y2="${gridY}" stroke="${gridColor}" stroke-width="${strokeWidth}"/>\n`;
                            }
                        }
                    } else {
                        // ê¸°ì¡´ ë¡œì§ - ë°ì´í„°ì— ë§ëŠ” ì ì ˆí•œ ê²©ìì„  ìƒì„±
const optimalInterval = calculateSmartGridInterval(min, max, range);
const startValue = Math.ceil(min / optimalInterval) * optimalInterval;

for (let value = startValue; value <= max; value += optimalInterval) {
    const strokeWidth = Math.abs(value) < 0.001 ? "2" : "0.5";
    
    if (horizontalBars) {
        const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
        svg += `            <line x1="${gridX}" y1="${y}" x2="${gridX}" y2="${y + height}" stroke="${gridColor}" stroke-width="${strokeWidth}"/>\n`;
    } else {
        const gridY = y + height - ((value - min) * height / range) * 0.9;
        svg += `            <line x1="${x + widthOffset}" y1="${gridY}" x2="${x + widthOffset + adjustedWidth}" y2="${gridY}" stroke="${gridColor}" stroke-width="${strokeWidth}"/>\n`;
    }
}
                    }
                }
            }
            
            // ì¶•
            svg += `            <line x1="${x + widthOffset}" y1="${y}" x2="${x + widthOffset}" y2="${y + height}" stroke="${textColor}" stroke-width="2"/>\n`;
            svg += `            <line x1="${x + widthOffset}" y1="${y + height}" x2="${x + widthOffset + adjustedWidth}" y2="${y + height}" stroke="${textColor}" stroke-width="2"/>\n`;
            
            // ì¶• ê°’ í‘œì‹œ
            if (showAxisLabels) {
                if (customGridlines) {
                    const numLinesUp = Math.floor(max / gridlineInterval);
                    const numLinesDown = Math.floor(Math.abs(min) / gridlineInterval);
                    
                    // ì–‘ìˆ˜ ë°©í–¥ ë ˆì´ë¸”
                    for (let i = 0; i <= numLinesUp; i++) {
                        const value = parseFloat((i * gridlineInterval).toFixed(10));
                        if (value > max) break;
                        
                        const formattedValue = formatAxisValue(value, useIntegerFormat);
                        
                        if (horizontalBars) {
                            const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
                            svg += `            <text x="${gridX}" y="${y + height + 15}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="middle">${formattedValue}</text>\n`;
                        } else {
                            const gridY = y + height - ((value - min) * height / range) * 0.9;
                            svg += `            <text x="${x + widthOffset - 15}" y="${gridY + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="end">${formattedValue}</text>\n`;
                        }
                    }
                    
                    // ìŒìˆ˜ ë°©í–¥ ë ˆì´ë¸”
                    for (let i = 1; i <= numLinesDown; i++) {
                        const value = parseFloat((-i * gridlineInterval).toFixed(10));
                        if (value < min) break;
                        
                        const formattedValue = formatAxisValue(value, useIntegerFormat);
                        
                        if (horizontalBars) {
                            const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
                            svg += `            <text x="${gridX}" y="${y + height + 15}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="middle">${formattedValue}</text>\n`;
                        } else {
                            const gridY = y + height - ((value - min) * height / range) * 0.9;
                            svg += `            <text x="${x + widthOffset - 15}" y="${gridY + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="end">${formattedValue}</text>\n`;
                        }
                    }
                } else {
                    // ê¸°ë³¸ ì¶• ê°’ í‘œì‹œ - ìŒìˆ˜ê°€ ìˆì„ ê²½ìš° 0ì„ í¬í•¨í•˜ë„ë¡ ìˆ˜ì •
                    if (min < 0 && max > 0) {
                        // ìŒìˆ˜ì™€ ì–‘ìˆ˜ê°€ ëª¨ë‘ ìˆëŠ” ê²½ìš° - 0ì„ ì¤‘ì‹¬ìœ¼ë¡œ ë ˆì´ë¸” ìƒì„±
                        const absMax = Math.max(Math.abs(min), Math.abs(max));
                        const step = absMax / 3;
                        
                        for (let i = -3; i <= 3; i++) {
                            const value = i * step;
                            if (value < min || value > max) continue;
                            
                            const formattedValue = formatAxisValue(value, useIntegerFormat);
                            
                            if (horizontalBars) {
                                const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
                                svg += `            <text x="${gridX}" y="${y + height + 15}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="middle">${formattedValue}</text>\n`;
                            } else {
                                const gridY = y + height - ((value - min) * height / range) * 0.9;
                                svg += `            <text x="${x + widthOffset - 15}" y="${gridY + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="end">${formattedValue}</text>\n`;
                            }
                        }
                    } else {
                        // ê¸°ì¡´ ë¡œì§ - ë°ì´í„°ì— ë§ëŠ” ì ì ˆí•œ ì¶• ë ˆì´ë¸” ìƒì„±
const optimalInterval = calculateSmartGridInterval(min, max, range);
const startValue = Math.ceil(min / optimalInterval) * optimalInterval;

for (let value = startValue; value <= max; value += optimalInterval) {
    const formattedValue = formatAxisValue(value, useIntegerFormat);
    
    if (horizontalBars) {
        const gridX = x + widthOffset + ((value - min) * adjustedWidth / range) * 0.9;
        svg += `            <text x="${gridX}" y="${y + height + 15}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="middle">${formattedValue}</text>\n`;
    } else {
        const gridY = y + height - ((value - min) * height / range) * 0.9;
        svg += `            <text x="${x + widthOffset - 15}" y="${gridY + 5}" font-family="AppleSDGothicNeo-Regular, 'Noto Sans KR', 'Malgun Gothic', AppleSDGothicNeo-Regular, sans-serif" font-size="12" fill="${textColor}" text-anchor="end">${formattedValue}</text>\n`;
    }
}
                    }
                }
            }
            
            svg += `        </g>\n`;
            return svg;
        }
        
        // Photopea PSD ë³€í™˜ (ê°œì„ ëœ ë²„ì „)
        function convertSVGtoPSD(svgData) {
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml' });
            const reader = new FileReader();
            
            reader.onload = function() {
                const dataUri = reader.result;
                const photopeaConfig = {
                    files: [dataUri],
                    environment: { 
                        veryCompact: true,
                        lang: "ko"
                    },
                    script: `
                        try {
                            // ê¸°ë³¸ ì„¤ì •
                            var width = 1920;
                            var height = 1080;
                            var resolution = 72;
                            var mode = DocumentMode.RGB;
                            var initialFill = DocumentFill.TRANSPARENT;
                            
                            // ìƒˆ ë¬¸ì„œ ìƒì„±
                            var doc = app.documents.add(width, height, resolution, "ì°¨íŠ¸_" + new Date().getTime(), mode, initialFill);
                            doc.colorProfileName = "sRGB IEC61966-2.1";
                            
                            // ê°€ì ¸ì˜¨ SVG ë¬¸ì„œ í™•ì¸
                            var importedDoc = null;
                            if (app.documents.length > 1) {
                                importedDoc = app.documents[app.documents.length - 1];
                                if (importedDoc !== doc) {
                                    app.activeDocument = importedDoc;
                                    
                                    // ì „ì²´ ë ˆì´ì–´ë¥¼ í•˜ë‚˜ë¡œ í•©ì¹˜ê¸°
                                    if (importedDoc.layers.length > 1) {
                                        importedDoc.flatten();
                                    }
                                    
                                    // ë©”ì¸ ë¬¸ì„œë¡œ ë³µì‚¬
                                    app.activeDocument = importedDoc;
                                    importedDoc.selection.selectAll();
                                    importedDoc.selection.copy();
                                    
                                    // ë©”ì¸ ë¬¸ì„œì— ë¶™ì—¬ë„£ê¸°
                                    app.activeDocument = doc;
                                    doc.paste();
                                    
                                    // ê°€ì ¸ì˜¨ ë¬¸ì„œ ë‹«ê¸°
                                    importedDoc.close(SaveOptions.DONOTSAVECHANGES);
                                }
                            }
                            
                            // ë©”ì¸ ë¬¸ì„œ í™œì„±í™”
                            app.activeDocument = doc;
                            
                            // ë ˆì´ì–´ ê·¸ë£¹ ìƒì„±
                            var chartGroup = doc.layerSets.add();
                            chartGroup.name = "ì°¨íŠ¸";
                            
                            var backgroundGroup = doc.layerSets.add();
                            backgroundGroup.name = "ë°°ê²½";
                            
                            // ê¸°ì¡´ ë ˆì´ì–´ë“¤ì„ ì ì ˆí•œ ê·¸ë£¹ìœ¼ë¡œ ì´ë™
                            var layers = [];
                            for (var i = 0; i < doc.layers.length; i++) {
                                if (doc.layers[i] !== chartGroup && doc.layers[i] !== backgroundGroup) {
                                    layers.push(doc.layers[i]);
                                }
                            }
                            
                            // ë ˆì´ì–´ë“¤ì„ ì°¨íŠ¸ ê·¸ë£¹ìœ¼ë¡œ ì´ë™
                            for (var i = 0; i < layers.length; i++) {
                                layers[i].move(chartGroup, ElementPlacement.INSIDE);
                            }
                            
                            // PSDë¡œ ì €ì¥
                            var saveFile = new File("~/Desktop/chart_" + new Date().getTime() + ".psd");
                            var psdOptions = new PhotoshopSaveOptions();
                            psdOptions.layers = true;
                            psdOptions.embedColorProfile = true;
                            
                            doc.saveAs(saveFile, psdOptions);
                            
                            alert("ì°¨íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ PSD íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\\n\\n" +
                                  "ì €ì¥ ìœ„ì¹˜: ë°”íƒ•í™”ë©´\\n" +
                                  "ë¬¸ì„œ í¬ê¸°: " + width + "Ã—" + height + "px\\n" +
                                  "í•´ìƒë„: " + resolution + " PPI\\n" +
                                  "ìƒ‰ìƒ ëª¨ë“œ: RGB 8bit\\n\\n" +
                                  "ë ˆì´ì–´ êµ¬ì¡°:\\n" +
                                  "â€¢ ì°¨íŠ¸ ê·¸ë£¹\\n" +
                                  "â€¢ ë°°ê²½ ê·¸ë£¹");
                                  
                        } catch (error) {
                            alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + error.toString() + "\\n\\n" +
                                  "SVG íŒŒì¼ì„ ìˆ˜ë™ìœ¼ë¡œ ê°€ì ¸ì˜¨ í›„ PSDë¡œ ì €ì¥í•´ì£¼ì„¸ìš”.\\n" +
                                  "File â†’ Place Embedded ë˜ëŠ” File â†’ Importë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.");
                        }
                    `
                };
                
                const configString = JSON.stringify(photopeaConfig);
                const encodedConfig = encodeURIComponent(configString);
                const photopeaUrl = `https://www.photopea.com/#${encodedConfig}`;
                
                window.open(photopeaUrl, 'photopea', 'width=1400,height=900,scrollbars=yes,resizable=yes');
            };
            
            reader.readAsDataURL(svgBlob);
        }
    
// ====================== Favorites Feature ======================
function getAllCurrentSettings() {
    return {
        typeSettings: typeSettings,
        chartConfig: chartConfig,
        numberOfLines: document.getElementById('numberOfLines')?.value,
        numberOfBars: document.getElementById('numberOfBars')?.value,
        numberOfPies: document.getElementById('numberOfPies')?.value,
        tableRows: tableRows,
        tableCols: tableCols,
        tableData: tableData,
        pieOptions: Array.from(document.querySelectorAll('[id^="isDonut"], [id^="isHalfPie"]')).map(el => ({
            id: el.id,
            checked: el.checked
        })),
        inputs: Array.from(document.querySelectorAll('input, select, textarea')).map(el => ({
            id: el.id,
            type: el.type,
            value: el.type === 'checkbox' ? el.checked : el.value
        }))
    };
}

function applyAllSettings(settings) {
    if (!settings) return;
    if (settings.typeSettings) { typeSettings = settings.typeSettings; }
    if (settings.chartConfig) chartConfig = settings.chartConfig;

    // Restore table dimensions and data first
    if (settings.tableRows && settings.tableCols) {
        tableRows = settings.tableRows;
        tableCols = settings.tableCols;
        document.getElementById('tableRowsCount').textContent = tableRows;
        document.getElementById('tableColsCount').textContent = tableCols;
        
        if (settings.tableData) {
            tableData = settings.tableData;
        }
    }

    // Restore number of series first
    if (settings.numberOfLines) document.getElementById('numberOfLines').value = settings.numberOfLines;
    if (settings.numberOfBars) document.getElementById('numberOfBars').value = settings.numberOfBars;
    if (settings.numberOfPies) document.getElementById('numberOfPies').value = settings.numberOfPies;
    updateSeriesContainers();

    // Restore inputs (general)
    settings.inputs.forEach(s => {
        const el = document.getElementById(s.id);
        if (el) {
            if (s.type === 'checkbox') {
                el.checked = s.value;
            } else {
                el.value = s.value;
            }
        }
    });

    // Restore pie-specific donut/halfPie checkboxes
    if (settings.pieOptions) {
        settings.pieOptions.forEach(opt => {
            const el = document.getElementById(opt.id);
            if (el) el.checked = opt.checked;
        });
    }

    generateChart();
}

function saveFavorite() {
    const name = document.getElementById('favoriteName').value.trim();
    if (!name) {
        alert('ì¦ê²¨ì°¾ê¸° ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.');
        return;
    }
    const settings = getAllCurrentSettings();
    localStorage.setItem('favorite_' + name, JSON.stringify(settings));
    localStorage.setItem('lastFavorite', 'favorite_' + name); // remember last saved
    updateFavoritesDropdown();
    alert('ì¦ê²¨ì°¾ê¸°ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: ' + name);
}

function loadFavorite(keyOverride = null) {
    const dropdown = document.getElementById('favoritesDropdown');
    const key = keyOverride || dropdown.value;
    if (!key) {
        alert('ë¶ˆëŸ¬ì˜¬ ì¦ê²¨ì°¾ê¸°ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
        return;
    }
    const settings = JSON.parse(localStorage.getItem(key));
    applyAllSettings(settings);
    // After applying all, also apply snapshot for current type if present
    try { applyTypeSettings(chartConfig.type); } catch(e) {}
    localStorage.setItem('lastFavorite', key); // remember last loaded
    if (!keyOverride) {
        alert('ì¦ê²¨ì°¾ê¸°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤: ' + key.replace('favorite_', ''));
    }
}

function deleteFavorite() {
    const dropdown = document.getElementById('favoritesDropdown');
    const key = dropdown.value;
    if (!key) {
        alert('ì‚­ì œí•  ì¦ê²¨ì°¾ê¸°ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
        return;
    }
    if (confirm('ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        localStorage.removeItem(key);
        updateFavoritesDropdown();
        alert('ì¦ê²¨ì°¾ê¸°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
}

function updateFavoritesDropdown() {
    const dropdown = document.getElementById('favoritesDropdown');
    dropdown.innerHTML = '';
    Object.keys(localStorage).forEach(k => {
        if (k.startsWith('favorite_')) {
            const option = document.createElement('option');
            option.value = k;
            option.textContent = k.replace('favorite_', '');
            dropdown.appendChild(option);
        }
    });
}

// Initialize favorites on load
document.addEventListener('DOMContentLoaded', () => {
    updateFavoritesDropdown();
    // auto-load last favorite if exists
    const last = localStorage.getItem('lastFavorite');
    if (last && localStorage.getItem(last)) {
        loadFavorite(last);
    }
});
// ====================== End Favorites Feature ======================


        // Draw arrow (supports negative direction)
        function drawArrow(ctx, x, y, width, height, color, isHorizontal, pointNegative=false) {
            const rawW = parseInt(document.getElementById('arrowHeadWidth')?.value) || 40;
            const rawH = parseInt(document.getElementById('arrowHeadHeight')?.value) || 30;
            const headW = Math.max(5, Math.min(rawW, Math.max(5, isHorizontal ? width*0.6 : width*2)));
            const headH = Math.max(5, Math.min(rawH, Math.max(5, isHorizontal ? height*2 : height*0.6)));
            ctx.fillStyle = color;
            ctx.beginPath();
            if (isHorizontal) {
                if (!pointNegative) { // â†’
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + width - headW, y);
                    ctx.lineTo(x + width - headW, y + (height - headH)/2);
                    ctx.lineTo(x + width, y + height/2);
                    ctx.lineTo(x + width - headW, y + (height + headH)/2);
                    ctx.lineTo(x + width - headW, y + height);
                    ctx.lineTo(x, y + height);
                } else { // â†
                    ctx.moveTo(x + width, y);
                    ctx.lineTo(x + headW, y);
                    ctx.lineTo(x + headW, y + (height - headH)/2);
                    ctx.lineTo(x, y + height/2);
                    ctx.lineTo(x + headW, y + (height + headH)/2);
                    ctx.lineTo(x + headW, y + height);
                    ctx.lineTo(x + width, y + height);
                }
            } else {
                if (!pointNegative) { // â†‘
                    ctx.moveTo(x, y + height);
                    ctx.lineTo(x, y + headH);
                    ctx.lineTo(x + (width - headW)/2, y + headH);
                    ctx.lineTo(x + width/2, y);
                    ctx.lineTo(x + (width + headW)/2, y + headH);
                    ctx.lineTo(x + width, y + headH);
                    ctx.lineTo(x + width, y + height);
                } else { // â†“
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + height - headH);
                    ctx.lineTo(x + (width - headW)/2, y + height - headH);
                    ctx.lineTo(x + width/2, y + height);
                    ctx.lineTo(x + (width + headW)/2, y + height - headH);
                    ctx.lineTo(x + width, y + height - headH);
                    ctx.lineTo(x + width, y);
                }
            }
            ctx.closePath();
            ctx.fill();
        }
    
</script>

  <!-- Added: Chart URL display field to prevent null element errors -->
  <div style="margin:12px 0;">
    <label for="chartUrl" style="display:block;font-weight:600;margin-bottom:4px;">Chart URL</label>
    <div id="chartUrl" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:6px;word-break:break-all;"></div>
  </div>

</body>
</html>